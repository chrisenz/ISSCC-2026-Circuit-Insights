---
title: |
  sEKV Parameter Extraction for the IHP 130nm Process
subtitle: pMOS Extrinsic Capacitances
author: Christian Enz (christian.enz@epfl.ch)
affiliation: EPFL
date: 2-14-2026
date-format: "DD.MM.YYYY"
execute:
  echo: false
  warning: false
toc: true
number-sections: true
number-depth: 4
highlight-style: pygments
bibliography: references.bib
csl: ieee.csl
format: 
  html:
    include-in-header: mathjax.html
    code-fold: true
    html-math-method: mathjax
    css: styles.css
    default-image-extension: svg
  pdf:
    keep-tex: true
    pdf-engine: pdflatex
    documentclass: scrreprt
    papersize: a4
    geometry:
      - top=20mm
      - bottom=20mm
      - left=20mm
      - right=20mm
    include-in-header:
      text: |
        \usepackage{scrlayer-scrpage}
        \rohead[\thepage]{\thepage}
        \cohead[pMOS Extrinsic Capacitances]{pMOS Extrinsic Capacitances}
        \lofoot[$\copyright$ C. Enz]{$\copyright$ C. Enz}
        \cofoot[sEKV Parameter Extraction for the IHP 130nm Process]{sEKV Parameter Extraction for the IHP 130nm Process}
        \rofoot[14.2.2026]{14.2.2026}
---

```{python}
# Initialization

from ekv_functions import *
from constants import *

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import subprocess
import shutil
import os
import os.path as op
import sys
sys.path.append(".")
import re

from PyLTSpice import SimRunner, SpiceEditor, RawRead
from IPython.display import Markdown
from tabulate import tabulate

plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'

lw=1
curvelw=1
msize=5
mevery=4
textFontSize=9
BodePlotParams = {'figure.figsize': (5,5)}
twoSidebySidePlotsParams = {'figure.figsize': (7, 2.7)}
twobytwoPlotsParams = {'figure.figsize': (7, 2.7)}
pltStyle='plt_style_small.mplstyle'
plt.style.use(pltStyle)

#newSim=True
newSim=False
refloat=r'.*?([+-]?\d+([.]\d*)?([eE][+-]?\d+)?|[.]\d+([eE][+-]?\d+)?)'

type='pmos'
tYPE='pMOS'
Type='pMOS (t-t)'
size='long'

def diff(y, dx):
    N=len(y)
    dydx=np.zeros(N)
    dydx[0]=(y[1]-y[0])/dx
    dydx[1]=(y[2]-y[0])/(2*dx)
    for k in range(2,N-2):
        dydx[k]=(y[k-2]-8*y[k-1]+8*y[k+1]-y[k+2])/(12*dx)
    dydx[N-2]=(y[N-1]-y[N-3])/(2*dx)
    dydx[N-1]=(y[N-1]-y[N-2])/dx
    return dydx
```


# Introduction
In this notebook we will extract the extrinsic capacitances, including junction, overlap and fringing capacitances for `{python} f'{tYPE}'` transistors of the 130nm bulk CMOS process from IHP @bib:ihp:2025. The parameters is extracted from the PDK of the IHP 130nm process @bib:ihp:2025.

# Transistor geometry parameters
## Effective length and width for current
Before we start the extraction we need to account for the geometry dependence. With PSP you can choose between geometry scaling rules or binning rules with parameter $SWGEO$. If $SWGEO=1$, the scaling rules are chosen. This is the case in the IHP 130nm G2 PDK. The geometrical parameters are defined in @fig-cross_section @bib:psp103.6:2017.

![Definition of transistor geometrical parameters @bib:psp103.6:2017.](Figures/transistor_cross_section.png){#fig-cross_section}

The effective length and width are defined as
\begin{align}
  L_{eff} &= L - \Delta L,\\
  W_{eff} &= W_f - \Delta W,
\end{align}
where $W_f$ is the width of one finger defined as
\begin{equation}
  W_f = \frac{W}{NF}.
\end{equation}
In our case we will assume that the number of fingers $NF=1$ and hence that $W_f = W$.
$\Delta L$ and $\Delta W$ are given by
\begin{align}
  \Delta L &= 2\,LAP - \Delta L_{PS},\\
  \Delta W &= 2\,WOT - \Delta W_{OD},
\end{align}
with
\begin{align}
  \Delta L_{PS} &= LVARO \cdot \left(1+LVARL \cdot \frac{L_{EN}}{L}\right) \cdot \left(1+LVARW \cdot \frac{W_{EN}}{W_f}\right),\\
  \Delta W_{OD} &= WVARO \cdot \left(1+WVARL \cdot \frac{L_{EN}}{L}\right) \cdot \left(1+WVARW \cdot \frac{W_{EN}}{W_f}\right).
\end{align}

Contrary to nMOS, for pMOS $LVARO \neq 0$ and $WVARO \neq 0$ and therefore $\Delta L_{PS} \neq 0$ and $\Delta W_{OD} \neq 0$. This means that the length and width reduction actually depend on the length $L$ and width $W$. However, we can ignore this scaling of $\Delta L_{PS}$ and $\Delta W_{OD}$ with $W$ and $L$ and approximate $\Delta L_{PS}$ and $\Delta W_{OD}$ by taking the value for $L \rightarrow \infty$ and for $W \rightarrow \infty$ corresponding to
\begin{align}
  \Delta L_{PS} &\cong LVARO,\\
  \Delta W_{OD} &\cong WVARO,
\end{align}
resulting in
\begin{align}
  \Delta L &\cong 2\,LAP - LVARO,\\
  \Delta W &\cong 2\,WOT - WVARO.
\end{align}

```{python}
# Parameters to calculate the effective length and width for pMOS extracted from sg13g2_moslv_parm.lib
LEN=1e-6
WEN=1e-6
lvaro = 9.695e-08
lvarl = -0.03438
lvarw =  0.0
lap = 2.5254e-08
wvaro =  0.0
wvarl =  0.0
wvarw =  0.0
wot = 1.5e-08

# Approximation of channel length and width reduction for current corresponding to infinite length and width transistor
DLp=2*lap-lvaro
DWp=2*wot-wvaro
```

The channel length and width reduction are then given in @tbl-length_width_corrections. Note that $\Delta L$ is negative which means that the effective length is longer than the drawn length.

## Effective length and width for capacitances
The effective length and width are slightly different for the calculation of the capacitances. The effective length and width for the calculation of the intrinsic and overlap capacitances are defined as
\begin{align}
  L_{E,CV} &= L - \Delta L_{CV},\\
  W_{E,CV} &= W - \Delta W_{CV},
\end{align}
where
\begin{align}
  \Delta L_{CV} &= 2\,LAP - \Delta L_{PS} - DLQ,\\
  \Delta W_{CV} &= 2\,WOT - \Delta W_{OD} - DWQ.
\end{align}

Similarly to the length and width reduction for the current, the length and width reduction for the capacitance in the case of pMOS transistors depends on the transistor width $W$ and length $L$. We can ignore this scaling of $\Delta L_{PS}$ and $\Delta W_{OD}$ by approximating them by the values obtained for for $W \rightarrow \infty$ and for $L \rightarrow \infty$ which leads to
\begin{align}
  \Delta L_{CV} &\cong 2\,LAP - LVARO - DLQ,\\
  \Delta W_{CV} &\cong 2\,WOT- WVARO - DWQ.
\end{align}

The effective length and width for the calculation of the fringing field capacitances are defined as
\begin{align}
  L_{G,CV} &= L - \Delta L_{G,CV},\\
  W_{G,ov} &= W - \Delta W_{G,CV},
\end{align}
where
\begin{align}
  \Delta L_{G,CV} &= - \Delta L_{PS} - DLQ,\\
  \Delta W_{G,CV} &= - \Delta W_{OD} - DWQ,
\end{align}
which can be approximated in the same way by
\begin{align}
  \Delta L_{G,CV} &\cong - LVARO - DLQ,\\
  \Delta W_{G,CV} &\cong - WVARO - DWQ.
\end{align}

```{python}
# Parameters extracted for pMOS from sg13g2_moslv_parm.lib
pre_layout = 1
dlq = -9.5922e-08-(1-pre_layout)*3e-08
dwq = 1.5e-08

# Approximation of channel length and width reduction for capacitance corresponding to infinite length and width transistor
DLCVp=2*lap-lvaro-dlq
DWCVp=2*wot-wvaro-dwq

# Similarly for the fringing capacitances
DLGCVp=-lvaro-dlq
DWGCVp=-wvaro-dwq
```

```{python}
#| label: tbl-length_width_corrections
#| tbl-cap: Length and width corrections.

sekv_geom_param_df={
    "Length correction DL": [DLp/1e-9, DLCVp/1e-9, DLGCVp/1e-9],
    "Width correction DW": [DWp/1e-9, DWCVp/1e-9, DWGCVp/1e-9],
    "Comment": "extracted from PDK"
}
index_labels=["For current","For intrinsic and overlap capacitances","For fringing-field capacitances"]
sekv_geom_param_df=pd.DataFrame(sekv_geom_param_df, index=index_labels)
#pd.set_option('display.float_format', '{:.3e}'.format)
#sekv_geom_param_df

Markdown(tabulate(
  sekv_geom_param_df,
  headers=["Definition","$\Delta L$ [nm]","$\Delta W$ [nm]","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center"),
  floatfmt=(".0f",".3f",".0f",".0f")
))
```

# Extrinsic capacitances
## Junction capacitances
The calculation of the junction capacitances depends on the value used for the **SWJUNCAP** parameter. In this PDK **SWJUNCAP** is equal to 3 for which the junction area $AB$, junction length of side-wall capacitance along the STI edge $LS$ and junction length of the side-wall capacitance along the gate edge $LG$ are calculated according to
\begin{align}
  AB &= AS,\\
  LS &= PS-W_E,\\
  LG &= W_E,\\
\end{align}
where $AS$ is the source junction area and $PS$ the total source junction perimeter and
\begin{align}
  AB &= AD,\\
  LS &= PD-W_E,\\
  LG &= W_E,\\
\end{align}
where $AD$ is the drain junction area and $PD$ the total drain junction perimeter.

The total junction capacitance on the source $CJS$ and drain side $CJD$ are then given by
\begin{align}
  CJS &= AS \cdot CJORBOT + (PS-W_E) \cdot CJORSTI + W_E \cdot CJORGAT,\\
  CJD &= AD \cdot CJORBOT + (PD-W_E) \cdot CJORSTI + W_E \cdot CJORGAT,
\end{align}
where:

  * **CJORBOT** is the zero-bias bottom capacitance per unit-area,
  * **CJORSTI** is the zero-bias capacitance per unit-of-length along the STI-edge,
  * **CJORGAT** is the zero-bias capacitance per unit-of-length along the gate-edge.

The above junction capacitance parameters are extracted directly from the PDK. We will use the the zero-bias bias value of th various junctions capacitances.

If $AS$, $PD$, $AD$ and $PD$ are not specified, they are calculated automatically in the sg13g2_moslv_mod.lib file.

In the circuit examples, we will calculate $AS$, $PD$, $AD$ and $PD$ for avoiding the automatic cal.culation

```{python}
#| label: tbl-junction_parameters
#| tbl-cap: Extraction of the junction capacitance parameters.

# Values for pMOS taken from the cornerMOSlv.lib file for t-t
sg13g2_lv_pmos_cjorbot = 1.0000
sg13g2_lv_pmos_cjorsti = 1.0000
sg13g2_lv_pmos_cjorgat = 1.0000

# Values for pMOS taken from the sg13g2_moslv_parm.lib file for t-t
cjorbot = 0.00086306*sg13g2_lv_pmos_cjorbot
cjorsti = 3.1915e-11*sg13g2_lv_pmos_cjorsti
cjorgat = 2.7474e-11*sg13g2_lv_pmos_cjorgat

# sEKV parameters
CJp = cjorbot
CJSWSTIp = cjorsti
CJSWGATp = cjorgat

sekv_juncap_param_df={
    "Zero-bias junction capacitance": [CJp, CJSWSTIp, CJSWGATp],
    "Unit": ["$\\frac{F}{m^2}$","$\\frac{F}{m}$","$\\frac{F}{m}$"],
    "Comment": ["extracted from PDK","extracted from PDK","extracted from PDK"]
}

index_labels=["Bottom cap per area","Side-wall cap per unit length (along STI)","Side-wall cap per unit length (along gate)"]
sekv_juncap_param_df=pd.DataFrame(sekv_juncap_param_df, index=index_labels)
#sekv_juncap_param_df

Markdown(tabulate(
  sekv_juncap_param_df,
  headers=["Definition","Zero-bias junction capacitance","Unit","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center"),
  floatfmt=(".0f",".3e",".0f",".0f")
))
```

## Overlap capacitances
In PSP, the gate-to-source and gate-to-drain overlap capacitances are equal and given by
\begin{equation}
  CGOV = \epsilon_{ox} \cdot \frac{W_{E,CV} \cdot LOV}{TOXOV},
\end{equation}
where the effective length $L_{E,CV}$ and width $W_{E,CV}$ for the calculation of the intrinsic and overlap acacitances are defined as
\begin{align}
  L_{E,CV} &= L + \Delta L_{CV},\\
  W_{E,CV} &= W + \Delta W_{CV},
\end{align}
where
\begin{align}
  \Delta L_{CV} &= 2\,LAP - \Delta L_{PS} - DLQ \cong 2\,LAP - LVARO - DLQ,\\
  \Delta W_{CV} &= 2\,WOT - \Delta W_{OD} - DWQ \cong 2\,WOT - WVARO - DWQ.
\end{align}

## Fringing capacitances
In PSP, the fringing field capacitance is given by
\begin{equation}
  CFR = CFRW \cdot \frac{W_{G,CV}}{W_{EN}},
\end{equation}
where
\begin{equation}
  W_{G,CV} = W_f + \Delta W_{OD} + DWQ \cong W_f + WVARO + DWQ
\end{equation}

The values of the overlap and fringing capacitances per effective unit width for $C_{GS}$ and $C_{GD}$ and per effective unit length for $C_{GB}$ are summarized in @tbl-overlap_parameters. We see that $CGBOn$ is almost negligible.

```{python}
#| label: tbl-overlap_parameters
#| tbl-cap: Overlap and fringing capacitances per effective unit width for $C_{GS}$ and $C_{GD}$ and per effective unit length for $C_{GB}$.

# Values for pMOS taken from the cornerMOSlv.lib file for t-t
sg13g2_lv_pmos_toxovo = 1.0000

# Values taken from the sg13g2_moslv_parm.lib file for t-t
pre_layout = 1.0
epsroxo = 3.9

# CGSo overlap capacitance per unit width
toxovo = 1.9704e-09*sg13g2_lv_pmos_toxovo
lov = 2.5254e-08-((1-pre_layout)*8.85e-09)
CGSOp = epsilon0*epsroxo*lov/toxovo
CGDOp = CGSOp

# CGBo overlap capacitance per unit length
cgbovl = 2.186e-17
CGBOp = cgbovl/LEN

# Fringing field capacitance per unit width
cfrw = 1e-16
CGSFp=cfrw/WEN
CGDFp=CGSFp

# Total extrinsic capacitance per unit width
CGSEp=CGSOp+CGSFp
CGDEp=CGDOp+CGDFp

sekv_extcap_param_df={
    "CGS": [CGSOp, CGSFp, CGSEp],
    "CGD": [CGDOp, CGDFp, CGDEp],
    "CGB": [f'{CGBOp:.3e}', "-", f'{CGBOp:.3e}'],
    "Unit": ["$\\frac{F}{m}$","$\\frac{F}{m}$","$\\frac{F}{m}$"],
    "Comment": "extracted from PDK"
}
index_labels=["Overlap","Fringing","Total"]
sekv_extcap_param_df=pd.DataFrame(sekv_extcap_param_df, index=index_labels)
#sekv_extcap_param_df

Markdown(tabulate(
  sekv_extcap_param_df,
  headers=["Definition","$C_{GS}$","$C_{GD}$","$C_{GB}$","Unit","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center","center"),
  floatfmt=(".0f",".3e",".3e",".3e",".0f",".0f")
))
```

# Conclusion
The parameters of the extrinsic capacitances, including junction, overlap and fringing capacitances have been extracted from the PDK of the IHP 130nm process for the for `{python} f'{tYPE}'` transistors.

# References
