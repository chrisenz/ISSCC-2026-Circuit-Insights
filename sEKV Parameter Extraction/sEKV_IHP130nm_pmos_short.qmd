---
title: |
  sEKV Parameter Extraction for the IHP 130nm Process
subtitle: pMOS (short-channel)
author: Christian Enz (christian.enz@epfl.ch)
affiliation: EPFL
date: 2-14-2026
date-format: "DD.MM.YYYY"
execute:
  echo: false
  warning: false
toc: true
number-sections: true
number-depth: 4
highlight-style: pygments
bibliography: references.bib
csl: ieee.csl
format: 
  html:
    include-in-header: mathjax.html
    code-fold: true
    html-math-method: mathjax
    css: styles.css
    default-image-extension: svg
  pdf:
    keep-tex: true
    pdf-engine: pdflatex
    documentclass: scrreprt
    papersize: a4
    geometry:
      - top=20mm
      - bottom=20mm
      - left=20mm
      - right=20mm
    include-in-header:
      text: |
        \usepackage{scrlayer-scrpage}
        \rohead[\thepage]{\thepage}
        \cohead[pMOS (short-channel)]{pMOS (short-channel)}
        \lofoot[$\copyright$ C. Enz]{$\copyright$ C. Enz}
        \cofoot[sEKV Parameter Extraction for the IHP 130nm Process]{sEKV Parameter Extraction for the IHP 130nm Process}
        \rofoot[14.2.2026]{14.2.2026}
---

```{python}
# Initialization

from ekv_functions import *
from constants import *

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import subprocess
import shutil
import os
import os.path as op
import sys
sys.path.append(".")
import re

from PyLTSpice import SimRunner, SpiceEditor, RawRead
from IPython.display import Markdown
from tabulate import tabulate

plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'

lw=1
curvelw=1
msize=5
mevery=4
textFontSize=9
BodePlotParams = {'figure.figsize': (5,5)}
twoSidebySidePlotsParams = {'figure.figsize': (7, 2.7)}
twobytwoPlotsParams = {'figure.figsize': (7, 2.7)}
pltStyle='plt_style_small.mplstyle'
plt.style.use(pltStyle)

#newSim=True
newSim=False
refloat=r'.*?([+-]?\d+([.]\d*)?([eE][+-]?\d+)?|[.]\d+([eE][+-]?\d+)?)'

type='pmos'
tYPE='pMOS'
Type='pMOS (t-t)'
size='short'

def diff(y, dx):
    N=len(y)
    dydx=np.zeros(N)
    dydx[0]=(y[1]-y[0])/dx
    dydx[1]=(y[2]-y[0])/(2*dx)
    for k in range(2,N-2):
        dydx[k]=(y[k-2]-8*y[k-1]+8*y[k+1]-y[k+2])/(12*dx)
    dydx[N-2]=(y[N-1]-y[N-3])/(2*dx)
    dydx[N-1]=(y[N-1]-y[N-2])/dx
    return dydx
```

# Introduction
In this notebook we will extract the sEKV parameters @bib:enz:book:2006 @bib:enz:sscmag:autumn:2017 for a `{python} f'{size}'`-channel `{python} f'{tYPE}'` transistors from the 130nm bulk CMOS process of IHP @bib:ihp:2025. The extraction is done with data generated using the PSP compact model @bib:psp103.6:2017 from the PDK of the IHP 130nm process @bib:ihp:2025 for the typical-typical (t-t) case.

The easiest way to extract the sEKV parameters is to use the python tool developed by H.C. Han and available on GitLab @bib:han:sekv:gitlab:2022. The tool and the extraction procedure are described in @bib:han:ojcas:3:sept:2022. In this notebook we will detail the extraction procedure and show how the parameters can be extracted manually.

We start by looking at the channel width and length corrections for the drain current and for the capacitances. Then we will extract the sEKV parameter using a direct extraction methodology with the velocity parameter $\lambda_c = 0$. We then will extract the additional parameter $\lambda_c$ using a direct extraction methodology. Then we will extract all the sEKV parameters by optimization using nonlinear curve fitting.

We also will extract the output conductance due to channel-length modulation (CLM) and the related parameter.

Finally, we will check the white noise model and extract the EKV flicker noise parameters.

The extracted parameters are then all saved in an Excel worksheet.

# Transistor geometry parameters
## Effective length and width for current
Before we start the extraction we need to account for the geometry dependence. With PSP you can choose between geometry scaling rules or binning rules with parameter $SWGEO$. If $SWGEO=1$, the scaling rules are chosen. This is the case in the IHP 130nm G2 PDK. The geometrical parameters are defined in @fig-cross_section @bib:psp103.6:2017.

![Definition of transistor geometrical parameters @bib:psp103.6:2017.](Figures/transistor_cross_section.png){#fig-cross_section}

The effective length and width are defined as
\begin{align}
  L_{eff} &= L - \Delta L,\\
  W_{eff} &= W_f - \Delta W,
\end{align}
where $W_f$ is the width of one finger defined as
\begin{equation}
  W_f = \frac{W}{NF}.
\end{equation}
In our case we will assume that the number of fingers $NF=1$ and hence that $W_f = W$.
$\Delta L$ and $\Delta W$ are given by
\begin{align}
  \Delta L &= 2\,LAP - \Delta L_{PS},\\
  \Delta W &= 2\,WOT - \Delta W_{OD},
\end{align}
with
\begin{align}
  \Delta L_{PS} &= LVARO \cdot \left(1+LVARL \cdot \frac{L_{EN}}{L}\right) \cdot \left(1+LVARW \cdot \frac{W_{EN}}{W_f}\right),\\
  \Delta W_{OD} &= WVARO \cdot \left(1+WVARL \cdot \frac{L_{EN}}{L}\right) \cdot \left(1+WVARW \cdot \frac{W_{EN}}{W_f}\right).
\end{align}

Contrary to nMOS, for pMOS $LVARO \neq 0$ and $WVARO \neq 0$ and therefore $\Delta L_{PS} \neq 0$ and $\Delta W_{OD} \neq 0$. This means that the length and width reduction actually depend on the length $L$ and width $W$. However, we can ignore this scaling of $\Delta L_{PS}$ and $\Delta W_{OD}$ with $W$ and $L$ and approximate $\Delta L_{PS}$ and $\Delta W_{OD}$ by taking the value for $L \rightarrow \infty$ and for $W \rightarrow \infty$ corresponding to
\begin{align}
  \Delta L_{PS} &\cong LVARO,\\
  \Delta W_{OD} &\cong WVARO,
\end{align}
resulting in
\begin{align}
  \Delta L &\cong 2\,LAP - LVARO,\\
  \Delta W &\cong 2\,WOT - WVARO.
\end{align}

```{python}
#| label: tbl-length_width_corrections
#| tbl-cap: Length and width corrections.

def effectiveL(W,L):
    DLPS=lvaro*(1+lvarl*LEN/L)*(1+lvarw*WEN/W)
    return L+DLPS-2*lap

def effectiveW(Wf,L):
    DWOD=wvaro*(1+wvarl*LEN/L)*(1+wvarw*WEN/Wf)
    return Wf+DWOD-2*wot

# Parameters to calculate the effective length and width for pMOS extracted from sg13g2_moslv_parm.lib
LEN=1e-6
WEN=1e-6
lvaro = 9.695e-08
lvarl = -0.03438
lvarw =  0.0
lap = 2.5254e-08
wvaro =  0.0
wvarl =  0.0
wvarw =  0.0
wot = 1.5e-08

# Selected geometry for extraction
W=10e-6
L=130e-9

# Approximation of channel length and width reduction for current corresponding to infinite length and width transistor
DLp=2*lap-lvaro
DWp=2*wot-wvaro

# Effective channel-width and length for selected geometry
#Leff=effectiveL(W,L)
#Weff=effectiveW(W,L)
Leff=L-DLp
Weff=W-DWp

sekv_geom_param_df={
    "Width correction DW": [DWp/1e-9],
    "Length correction DL": [DLp/1e-9],
    "Comment": "extracted from PDK"
}
index_labels=["For current"]
sekv_geom_param_df=pd.DataFrame(sekv_geom_param_df, index=index_labels)
pd.set_option('display.float_format', '{:.3e}'.format)
sekv_geom_param_df

Markdown(tabulate(
  sekv_geom_param_df,
  headers=["Definition","$\\Delta W$ [nm]","$\\Delta L$ [nm]","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center"),
  floatfmt=(".0f",".3f",".3f",".0f")
))
```

The channel length and width reduction are then given in @tbl-length_width_corrections. Note that, contrary to the nMOS devices, for `{python} f'{tYPE}'` $\Delta L =$ `{python} f'{DLp/1e-9:.3f}'` $nm$ is negative wich leads to an effective length that is longer than the drawn length. On the other hand $\Delta W =$ `{python} f'{DWp/1e-9:.3f}'` $nm$ is positive which results in an effective width that is smaller than the drawn width. The width and length for the selected `{python} f'{tYPE}'` transistor are given by $W =$ `{python} f'{W/1e-6:.0f}'` $\mu m$ and $L =$ `{python} f'{L/1e-6:.0f}'` $\mu m$ and the effective width and length are given by $W_{{eff}} =$ `{python} f'{Weff/1e-6:.3f}'` $\mu m$ and $L_{eff} =$ `{python} f'{Leff/1e-6:.3f}'` $\mu m$. They are summarized in @tbl-mos_geometry.

```{python}
#| label: tbl-mos_geometry
#| tbl-cap: Selected transistor width and length.

table = [[tYPE,W/1e-6,Weff/1e-6,L/1e-9,Leff/1e-9]
         ]

Markdown(tabulate(
  table,
  headers=["Type","$W\\;[\\mu m]$","$W_{eff}\\;[\\mu m]$","$L\\;[nm]$","$L_{eff}\\;[nm]$"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center"),
  floatfmt=(".0f",".0f",".3f",".0f",".0f")
))
```

# DC Transfer Characteristic Parameters
## Generating and importing the data
The data used for the sEKV parameters extraction is generated by simulation using ngspice with the PSP CM @bib:psp103.6:2017 from the PDK of the IHP 130nm process @bib:ihp:2025 for the typical-typical (t-t) case. We present the $I_D$-$V_G$ and $G_m$-$V_G$ data below.

```{python}
simulationPath="./Simulations/" + type + "/idgmvg/"
dataPath="./Data/" + type + "/"
fileName = "idgmvg"
dataFile = dataPath + fileName + "_" + type + "_" + size + ".dat"
paramFile = simulationPath + fileName + ".par"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"

VG=1
VS=0
VD=1.5

Npts=201
VGmin=-0.5
VGmax=1.5
dVG=(VGmax-VGmin)/(Npts-1)

if newSim:
    paramstr = '\n'.join((
        f'.param W={W/1e-6:.2f}u L={L/1e-6:.2f}u VG={VG:.1f} VS={VS:.1f} VD={VD:.1f}',
        f'.csparam VGmin = {VGmin:.3f}',
        f'.csparam VGmax = {VGmax:.3f}',
        f'.csparam dVG = {dVG:.3f}'
    ))
    #print(paramstr)
    with open(paramFile, 'w') as f:
        f.write(paramstr)
    print('Starting ngspice simulation...\n')
    result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
    if result.stderr == '':
        print("Simulation executed successfully.\n")
    else:
        print("Simulation failed with return code", result.stderr)
    print(result.stdout)
    f = open(simulationPath + fileName + ".log", 'r')
    log_contents = f.read()
    print("Contents of the log file:")
    print("‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n")
    print (log_contents)
    # We copy the simulation results to the dat folder
    shutil.copy2(simulationData, dataFile)
```

### I~D~ and G~m~ versus V~G~

```{python}
#| label: fig-id_gm_vg_imported_log
#| fig-cap: Imported $I_D$-$V_G$ and $G_m$-$V_G$.

df_idgmvg=pd.read_table(dataFile, sep=' +', engine='python')
VG=df_idgmvg['v-sweep'].to_numpy()
ID=df_idgmvg['ID'].to_numpy()
Gm=df_idgmvg['Gm'].to_numpy()

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(7, 2.7), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].semilogy(VG, ID/1e-6, 'r-o', markersize=msize, markevery=mevery)
axs[0].set_xlabel('$V_G$ [V]')
axs[0].set_xlim(VGmin,VGmax)
#axs[0].set_xticks(np.arange(0,2.2,0.2))
axs[0].set_ylabel('$I_D$ [$\\mu A$]')
#axs[0].set_ylim(1e-4,1e3)
#axs[0].legend(loc='upper left')
mosinfo = '\n'.join((
    Type,
    f'$W =$ {W/1e-6:.0f} $\\mu m$',
    f'$L =$ {L/1e-9:.0f} $nm$',
    f'$V_S =$ {VS:.0f} V',
    f'$V_D =$ {VD:.1f} V'))
axs[0].text(0.7, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogy(VG, abs(Gm)/1e-6, 'r-o', markersize=msize, markevery=mevery)
axs[1].set_xlabel('$V_G$ [V]')
axs[1].set_xlim(VGmin,VGmax)
#axs[1].set_xticks(np.arange(0,2.2,0.2))
axs[1].set_ylabel('$|G_m|$ [$\\mu A/V$]')
#axs[1].set_ylim(0,)
#axs[1].legend(loc='lower right')
axs[1].text(0.7, 0.05, mosinfo, ha='left', va='bottom', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

```{python}
#| label: fig-id_vg_imported
#| fig-cap: Imported $I_D$-$V_G$.

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(8, 3), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].semilogy(VG, ID/1e-6, 'r-o', markersize=msize, markevery=mevery)
axs[0].set_xlabel('$V_G$ [V]')
axs[0].set_xlim(VGmin,VGmax)
#axs[0].set_xticks(np.arange(0,2.2,0.2))
axs[0].set_ylabel('$I_D$ [$\\mu A$]')
#axs[0].set_ylim(1e-4,1e3)
#axs[0].legend(loc='upper left')
axs[0].text(0.7, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].plot(VG, ID/1e-6, 'r-o', markersize=msize, markevery=mevery)
axs[1].set_xlabel('$V_G$ [V]')
axs[1].set_xlim(VGmin,VGmax)
#axs[1].set_xticks(np.arange(0,2.2,0.2))
axs[1].set_ylabel('$I_D$ [$\\mu A$]')
axs[1].set_ylim(0,)
#axs[1].legend(loc='lower right')
axs[1].text(0.05, 0.95, mosinfo, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

```{python}
#| label: fig-id_sqrtid_vg_imported
#| fig-cap: Imported $I_D$-$V_G$.

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(8, 3), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].semilogy(VG, ID/1e-6, 'r-o', markersize=msize, markevery=mevery)
axs[0].set_xlabel('$V_G$ [V]')
axs[0].set_xlim(VGmin,VGmax)
#axs[0].set_xticks(np.arange(0,2.2,0.2))
axs[0].set_ylabel('$I_D$ [$\\mu A$]')
#axs[0].set_ylim(1e-4,1e3)
#axs[0].legend(loc='upper left')
axs[0].text(0.7, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].plot(VG, sqrt(ID)/1e-3, 'r-o', markersize=msize, markevery=mevery)
axs[1].set_xlabel('$V_G$ [V]')
axs[1].set_xlim(VGmin,VGmax)
#axs[1].set_xticks(np.arange(0,2.2,0.2))
axs[1].set_ylabel('$\\sqrt{{I_D}}$ [$\\sqrt{{\\mu A}}$]')
axs[1].set_ylim(0,)
#axs[1].legend(loc='lower right')
axs[1].text(0.05, 0.95, mosinfo, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

### G~m~-V~G~ and G~m~-I~D~
We now will check the derivative namely the gate transconductance obtained from the simulator and compare it to the numerical differentiation of the large-signal $I_D$-$V_G$ characteristic.

```{python}
#| label: fig-gm_vg_check
#| fig-cap: Check of the $G_m$-$V_G$ consistency.

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]
Gmnum=np.zeros(Npts)
dVG=VG[1]-VG[0]
Gmnum=diff(ID,dVG)

plt.style.use(pltStyle)
plt.semilogy(VG, abs(Gm)/1e-6,'ro', label='Data', markersize=msize, markevery=mevery)
plt.semilogy(VG, abs(Gmnum)/1e-6,'b-', label='Num. diff.')
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin,VGmax)
#plt.xticks(np.arange(0,2.2,0.2))
plt.ylabel('$G_m$ [$\\mu A/V$]')
#plt.ylim(1e-11,1e-3)
#plt.yticks([1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.legend(loc='lower right')
plt.text(0.75, 0.5, mosinfo, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

```{python}
#| label: fig-gm_id_check
#| fig-cap: Check of the $G_m$-$I_D$ consistency.

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]

plt.style.use(pltStyle)
plt.loglog(ID, Gm,'ro', label='Data', markersize=msize, markevery=mevery)
plt.loglog(ID, Gmnum,'b-', label='Num. diff.')
plt.xlabel('$I_D$ [A]')
#plt.xlim(1e-12,1e-3)
#plt.xticks([1e-12,1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.ylabel('$G_m$ [A/V]')
#plt.ylim(1e-11,1e-3)
#plt.yticks([1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.legend(loc='lower right')
textstr = '\n'.join((
    f'$W =$ {W/1e-6:.0f} $\\mu m$',
    f'$L =$ {L/1e-6:.0f} $\\mu m$'))
plt.text(0.05, 0.95, mosinfo, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

We see that the transconductance obtained by differentiating the large-signal $I_D$-$V_G$ characteristic is equal to the transconductance extracted from the PSP model. We will keep the value extracted from the PSP model.

## Filtering the outliers
Since the sEKV model @bib:enz:sscmag:autumn:2017 doesn't account for GIDL that appears at very low current, we need to filter the outlier points. This is done below.

```{python}
#| label: fig-id_vg_outliers
#| fig-cap: Filtering the outliers from the $I_D$-$V_G$ charactersitic.

VGmini=0
VGmaxi=1.5

VGsub=VG[(VG >= VGmini) & (VG <= VGmaxi)]
Nsub=len(VGsub)
Nmin=np.where(VG == VGsub[0])[0][0]
Nmax=np.where(VG == VGsub[Nsub-1])[0][0]

IDsub=np.zeros(Nsub)
Gmsub=np.zeros(Nsub)

for k in range(0,Nsub):
    IDsub[k]=ID[Nmin+k]
    Gmsub[k]=Gm[Nmin+k]

Nfil=Npts-Nsub
VGfil=np.zeros(Nfil)
IDfil=np.zeros(Nfil)
Gmfil=np.zeros(Nfil)

for k in range(0,Nfil):
    VGfil[k]=VG[k]
    IDfil[k]=ID[k]
    Gmfil[k]=Gm[k]

plt.style.use(pltStyle)
plt.semilogy(VGfil, IDfil, 'b-o', label='Outliers', markersize=msize, markevery=4)
plt.semilogy(VGsub ,IDsub, 'r-o', label='Selected', markersize=msize, markevery=4)
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin,VGmax)
#plt.xticks(np.arange(0,2.2,0.2))
plt.ylabel('$I_D$ [A]')
#plt.ylim(1e-12,1e-3)
#plt.yticks([1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.legend(loc='lower right')
plt.text(0.75, 0.5, mosinfo, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_ID_VG_outliers')
plt.show()
```

```{python}
#| label: fig-gm_vg_outliers
#| fig-cap: Filtering the outliers from the $G_m$-$V_G$ charactersitic.

plt.style.use(pltStyle)
plt.semilogy(VGfil,abs(Gmfil),'b-o', label='Outliers', markersize=msize, markevery=2)
plt.semilogy(VGsub,abs(Gmsub),'r-o', label='Selected', markersize=msize, markevery=4)
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin, VGmax)
#plt.xticks(np.arange(0,2.2,0.2))
plt.ylabel('$G_m$ [A/V]')
#plt.ylim(1e-10,1e-3)
#plt.yticks([1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.legend(loc='lower right')
plt.text(0.75, 0.5, mosinfo, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_Gm_VG_outliers')
plt.show()
```

```{python}
#| label: fig-gm_id_outliers
#| fig-cap: Filtering the outliers from the $G_m$-$I_D$ charactersitic.

plt.style.use(pltStyle)
plt.loglog(IDfil,Gmfil,'b-o', label='Outliers', markersize=msize, markevery=2)
plt.loglog(IDsub,Gmsub,'r-o', label='Selected', markersize=msize, markevery=4)
plt.xlabel('$I_D$ [A]')
#plt.xlim(1e-10,1e-3)
#plt.xticks([1e-12,1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.ylabel('$G_m$ [A/V]')
#plt.ylim(1e-9,1e-3)
#plt.yticks([1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.legend(loc='lower right')
plt.text(0.75, 0.5, mosinfo, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

```{python}
VG=VGsub
ID=IDsub
Gm=Gmsub
```

We can now proceed with the parameter extraction, starting with the direct extraction approach with $\lambda_c = 0$.

## Direct extraction with $\lambda_c=0$
In the direct extraction approach, we avoid using curve fitting or optimization and manipulate the data to extract a given parameter in a certain data range. We start extracting the slope factor $n$ and the specific current $I_{spec}$.

### Slope factor $n$ and $I_{spec}$ extraction
The gate transconductance in weak inversion and saturation is given by @bib:enz:book:2006
\begin{equation}
  G_m = \frac{I_D}{n\,U_T}.
\end{equation}
So if we plot $I_D/(G_m\,U_T)$ we should see a plateau in weak inversion the value of which is equal to the slope factor $n$.

```{python}
#| label: fig-slope_ext_lc0
#| fig-cap: Slope factor extraction.

Npts=len(VG)
next=np.zeros(Npts)

for k in range(0,Npts):
    next[k]=ID[k]/(Gm[k]*UT)

nextmin=np.min(next)
Nmin=np.where(next == nextmin)[0]
IDext=ID[Nmin[0]]
n0=round(nextmin,2)

plt.style.use(pltStyle)
plt.loglog(ID,next,'r-o', markersize=msize, markevery=mevery)
plt.loglog([1e-12,IDext],[n0,n0],'k--', linewidth=lw)
plt.loglog([IDext,IDext],[1,n0],'k--', linewidth=lw)
plt.loglog(ID[Nmin],next[Nmin],'ko', markersize=msize)
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.xlabel('$I_D$ [A]')
plt.ylim(1,1e2)
plt.ylabel('$I_D/(G_m\\,U_T)$ [-]')
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.annotate('$n =$' + f'{n0:.2f}', size=9,
             xy=(1e-10, n0), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate('$I_D =$' + f'{IDext/1e-9:.0f} nA', size=9,
             xy=(IDext, 1), xycoords='data',
             xytext=(-30, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n0:.2f}'))
plt.text(0.03, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_n_direct')
plt.show()
```

This is illustrated in @fig-slope_ext_lc0 resulting in $n =$ `{python} f'{n0:.2f}'`, which is higher than the long- and medium-channel `{python} f'{tYPE}'` transistor. On the other hand the normalized $G_m/I_D$ function for a long-channel transistor in strong inversion and saturation is given by @bib:enz:book:2006
\begin{equation}
  \frac{G_m\,n\,U_T}{I_D} = \frac{1}{\sqrt{IC}} = \sqrt{\frac{I_{spec}}{I_D}}.
\end{equation}
We can then plot $(G_m\,n\,U_T)^2/I_D$ which should find a maximum value equal to $I_{spec}$.

```{python}
#| label: fig-ispec_ext_lc0
#| fig-cap: $I_{spec}$ extraction.

Ispecext=np.zeros(Npts)
nUT=n0*UT

for k in range(0,Npts):
    Ispecext[k]=(Gm[k]*nUT)**2/ID[k]

Ispec0=np.max(Ispecext)
Ispecsq0=Ispec0/(Weff/Leff)
Nmax=np.where(Ispecext == Ispec0)[0]
IDext=ID[Nmax[0]]

plt.style.use(pltStyle)
plt.loglog(ID,Ispecext,'r-o', markersize=msize, markevery=mevery)
plt.loglog([1e-12,IDext],[Ispec0,Ispec0],'k--', linewidth=lw)
plt.loglog([IDext,IDext],[1e-12,Ispec0],'k--', linewidth=lw)
plt.loglog(ID[Nmax],Ispecext[Nmax],'ko', markersize=msize)
plt.xlabel('$I_D$ [A]')
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.ylabel('$(G_m\\,n\\,U_T)^2/I_D$ [A]')
plt.ylim(1e-10,1e-4)
plt.annotate(f'$I_{{spec}} =$ {Ispec0/1e-6:.1f} $\\mu A$', size=9,
             xy=(1e-10, Ispec0), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate('$I_D =$' + f'{IDext/1e-6:.1f} $\\mu A$', size=9,
             xy=(IDext, 1e-10), xycoords='data',
             xytext=(0, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n0:.2f}',
    f'$I_{{spec}} =$ {Ispec0/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq0/1e-9:.0f} nA'))
plt.text(1.05, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_Ispec_direct')
plt.show()
```

This is illustrated in @fig-ispec_ext_lc0 resulting in $I_{spec} =$ `{python} f'{Ispec0/1e-6:.3f}'` $\mu A$ corresponding to $I_{spec\Box} =$ `{python} f'{Ispecsq0/1e-9:.0f}'` $nA$. We can now plot $I_D/(G_m\,U_T)$ versus $I_D$ as shown in @fig-idgm_id_n_ispec_check_lc0. We clearly see the two asymptotes in weak (i.e. $I_D < I_{spec}$) and strong inversion (i.e. $I_D > I_{spec}$).

```{python}
#| label: fig-idgm_id_n_ispec_check_lc0
#| fig-cap: $n$ and $I_{spec}$ check.

#The values of n, Ispecsq, Ispec are updated to the extracted values n0, Ispecsq0 and Ispec
#in order to keep always the same script for the plots that are not related to an extraction
n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0

Next=101
IDsi=np.linspace(Ispec0,1e-2,Next,endpoint=True)
IDGmUTsi=np.zeros(Next)

for k in range(0,Next):
    IDGmUTsi[k]=n*sqrt(IDsi[k]/Ispec)

plt.style.use(pltStyle)
plt.loglog(ID,next,'r-o', markersize=msize, markevery=2)
plt.loglog(IDsi,IDGmUTsi,'k--', linewidth=lw)
plt.loglog([1e-12,Ispec],[n,n],'k--', linewidth=lw)
plt.loglog([Ispec,Ispec],[1,n],'k--', linewidth=lw)
plt.xlabel('$I_D$ [A]')
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.ylabel('$I_D/(G_m\\,U_T)$ [-]')
plt.ylim(1,1e2)
plt.annotate(f'$n =$ {n:.2f}', size=9,
             xy=(1e-10, n), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate(f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$', size=9,
             xy=(Ispec, 1), xycoords='data',
             xytext=(30, -40), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='bottom')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA'))
plt.text(0.03, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_n_Ispec')
plt.show()
```

Having extracted $n$ and $I_{spec}$, we can now plot the normalized $G_m/I_D$ function versus $IC$ which is shown in @fig-gmid_ic_n_ispec_check_lc0.

```{python}
#| label: fig-gmid_ic_n_ispec_check_lc0
#| fig-cap: $n$ and $I_{spec}$ check.

#The values of n, Ispecsq, Ispec are updated to the extracted values n0, Ispecsq0 and Ispec
#in order to keep always the same script for the plots that are not related to an extraction
n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0
nUT=n*UT
lambdac=0
Lsat=0

ICsim=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)

for k in range(0,Npts):
    ICsim[k]=ID[k]/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

plt.style.use(pltStyle)
plt.loglog([1e-3,1],[1,1],'k--', linewidth=lw)
plt.loglog([1,1e2],[1,1e-1],'k--', linewidth=lw)
plt.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
plt.loglog(ICsim,gmidsim,'ro', markersize=msize, markevery=2)
plt.loglog(ICmod,gmidmod,'b-')
plt.xlabel('$IC$ [-]')
plt.xlim(1e-3,1e3)
#plt.xticks(np.arange(0,11,1))
plt.ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
plt.ylim(1e-2,)
#plt.yticks(np.arange(0,1.1,0.1))
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$\\lambda_c =$ {lambdac:.0f}'))
plt.text(0.03, 0.05, textstr, ha='left', va='bottom', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_GmID_direct')
plt.show()
```

The fit is reasonable over the entire $IC$ span. There is some small discrepancy in the moderate inversion region but mostly in strong inversion for $IC >10^2$. This is due to the combined effects of velocity saturation (VS) and mobility reduction due to the vertical field. For the short-channel transistor it is probably mostly due to VS which can be accounted for by using the $\lambda_c$ parameter. We will not do this here since we want to extract the long-channel parameters keeping $\lambda_c = 0$, but since we are mostly interested in the moderate inversion region, we can slightly increase $I_{spec}$ to improve the fit in moderate inversion at the cost of a degradation in strong inversion. This results in the normalized $G_m/I_D$ function versus $IC$ shown in @fig-gmid_ic_n_ispec_fit_lc0.

```{python}
#| label: fig-gmid_ic_n_ispec_fit_lc0
#| fig-cap: Fine tuning of the normalized $G_m/I_D$ function versus $IC$ in moderate inversion.

Ispecsq=400e-9
Ispec=Ispecsq*Weff/Leff

ICsim=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)

for k in range(0,Npts):
    ICsim[k]=ID[k]/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

plt.style.use(pltStyle)
plt.loglog([1e-3,1],[1,1],'k--', linewidth=lw)
plt.loglog([1,1e2],[1,1e-1],'k--', linewidth=lw)
plt.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
plt.loglog(ICsim,gmidsim,'ro', markersize=msize, markevery=2)
plt.loglog(ICmod,gmidmod,'b-')
plt.xlabel('$IC$ [-]')
plt.xlim(1e-3,1e3)
#plt.xticks(np.arange(0,11,1))
plt.ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
plt.ylim(1e-2,)
#plt.yticks(np.arange(0,1.1,0.1))
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$\\lambda_c =$ {lambdac:.0f}'))
plt.text(0.03, 0.05, textstr, ha='left', va='bottom', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_GmID_direct_modified')
plt.show()
```

The fit is now much better in moderate inversion but less in strong inversion. However, it offers a good trade-off between moderate inversion (where the curve is slightly below the simulations) and strong inversion up to $IC = 100$ (where the simulation points are slightly below the curve). We therefore will keep the new value of $I_{spec\Box}$, namely $I_{spec\Box} =$ `{python} f'{Ispecsq/1e-9:.0f}'` $nA$.

### Threshold voltage extraction
We can extract the threshold voltage in weak inversion (assuming $V_S=0$) from the normalized current (inversion coefficient) given by @bib:enz:book:2006
\begin{equation}
  IC = e^{\frac{V_G-V_{T0}}{n U_T}}.
\end{equation}
We can now plot
\begin{equation}
  V_{T0} = V_G -n U_T \ln(IC)
\end{equation}
to extract the threshold voltage. This results in the plot shown in @fig-vt0ext_vg_lc0.

```{python}
#| label: fig-vt0ext_vg_lc0
#| fig-cap: Threshold voltage extraction.

# We keep the initial values of n, Ispecsq and Ispec
#n=n0
#Ispecsq=Ispecsq0
#Ispec=Ispec0
# We keep the new values of n, Ispecsq and Ispec
n0=n
Ispecsq0=Ispecsq
Ispec0=Ispec
nUT=n*UT

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]

ICsim=np.zeros(Npts)
VT0ext=np.zeros(Npts)

nUT=n0*UT

for k in range(0,Npts):
    ICsim[k]=ID[k]/Ispec
    VT0ext[k]=VG[k]-nUT*ln(ICsim[k])

plt.style.use(pltStyle)
plt.plot(VG,VT0ext,'r-o', markersize=msize, markevery=mevery)
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin,VGmax)
#plt.xticks(np.arange(0,2.2,0.2))
plt.ylabel('$V_{T0ext}$ [V]')
#plt.ylim(0,1.8)
#plt.yticks(np.arange(0,1.1,0.1))
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$\\lambda_c =$ {lambdac:.0f}'))
plt.text(0.05, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_VT0_direct')
plt.show()
```

We see a plateau in weak inversion where we can average its value to get the threshold voltage in weak inversion which we can zoom into as shown in @fig-vt0ext_vg_wi_lc0.

```{python}
#| label: fig-vt0ext_vg_wi_lc0
#| fig-cap: Threshold voltage extraction in weak inversion.

VGmin=0
VGmax=0.3
VGsub=VG[(VG >= VGmin) & (VG <= VGmax)]
Nsub=len(VGsub)
Nmin=np.where(VG == VGsub[0])[0][0]
Nmax=np.where(VG == VGsub[Nsub-1])[0][0]

ICsub=np.zeros(Nsub)
VT0sub=np.zeros(Nsub)

for k in range(0,Nsub):
    ICsub[k]=ID[Nmin+k]/Ispec0
    VT0sub[k]=VGsub[k]-nUT*ln(ICsub[k])

VT0wi=np.mean(VT0sub)
#display(Latex(f'$V_{{T0,wi}}  =$ {VT0wi/1e-3:.0f} mV'))

plt.style.use(pltStyle)
plt.plot(VGsub,VT0sub,'r-o', markersize=msize, markevery=1)
plt.plot([VGmin,VGmax],[VT0wi,VT0wi], 'k--')
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin,VGmax)
#plt.xticks(np.arange(0,11,1))
plt.ylabel('$V_{T0ext}$ [V]')
plt.ylim(0,0.8)
#plt.yticks(np.arange(0,1.1,0.1))
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.annotate('$V_{{T0}} =$' + f'{VT0wi:.3f}', size=9,
             xy=(VGmin, VT0wi), xycoords='data',
             xytext=(50, 30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$V_{{T0}} =$ {VT0wi/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.0f}'))
plt.text(1.03, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_VT0_average')
plt.show()
```

The average value of $V_{T0}$ in this range is given by $V_{T0} =$ `{python} f'{VT0wi/1e-3:.0f}'` $mV$. We can now plot the $I_D$-$V_G$ for the extracted parameters which is shown in @fig-id_vg_vt0_check_lc0.

```{python}
#| label: fig-id_vg_vt0_check_lc0
#| fig-cap: $I_D$-$V_G$ for the extracted parameters.

n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0
nUT=n*UT
VT0=VT0wi

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]
VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idsim=np.zeros(Npts)
idmod=np.zeros(Npts)

for k in range(0,Npts):
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps(vps[k])
    idsim[k]=ID[k]/Ispec

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(9, 3.5), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[0].semilogy(VGT,idmod, 'b-', label='sEKV')
axs[0].set_xlabel('$V_G-V_{T0}$ [V]')
axs[0].set_xlim(-0.4,1.2)
axs[0].set_xticks(np.arange(-0.4,1.4,0.2))
axs[0].set_ylabel('$I_D/I_{spec}$')
axs[0].set_ylim(1e-4,1e3)
axs[0].legend(loc='upper left')
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$V_{{T0}} =$ {VT0/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.0f}'))
axs[0].text(0.65, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[1].plot(VGT,idmod, 'b-', label='sEKV')
axs[1].set_xlabel('$V_G-V_{T0}$ [V]')
axs[1].set_xlim(-0.4,1.2)
axs[1].set_xticks(np.arange(-0.4,1.4,0.2))
axs[1].set_ylabel('$I_D/I_{spec}$')
axs[1].set_ylim(0,)
axs[1].legend(loc='lower right')
axs[1].text(0.05, 0.95, textstr, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

We get a reasonable fit with some deviations in strong inversion, which is expected since we focused on the moderate inversion and kept $\lambda_c = 0$.

Note that we can also extract the threshold voltage in strong inversion by plotting $\sqrt{I_D}$ versus $V_G$ as shown in @fig-sqrtid_vg_vt0_check_lc0.

```{python}
#| label: fig-sqrtid_vg_vt0_check_lc0
#| fig-cap: $\sqrt{I_D}$-$V_G$ for the extracted parameters.

# We keep the initial values of n, Ispecsq and Ispec
#n=n0
#Ispecsq=Ispecsq0
#Ispec=Ispec0
# We keep the new values of n, Ispecsq and Ispec
n0=n
Ispecsq0=Ispecsq
Ispec0=Ispec
nUT=n*UT

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]

plt.style.use(pltStyle)
plt.plot(VG,sqrt(abs(ID)),'r-o', markersize=msize, markevery=mevery)
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin,VGmax)
#plt.xticks(np.arange(0,2.2,0.2))
plt.ylabel('$\\sqrt{I_D}$ [$\\sqrt{A}$]')
#plt.ylim(0,1.8)
#plt.yticks(np.arange(0,1.1,0.1))
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$\\lambda_c =$ {lambdac:.0f}'))
plt.text(0.05, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_VT0_direct')
plt.show()
```

```{python}
#| label: fig-sqrtid_vg_vt0_ext_lc0
#| fig-cap: Threshold voltage extraction from $\sqrt{I_D}$-$V_G$ in strong inversion.

from scipy.stats import linregress

VGmini=0.5
VGmaxi=1
VGsub=VG[(VG >= VGmini) & (VG <= VGmaxi)]
Nsub=len(VGsub)
Nmin=np.where(VG == VGsub[0])[0][0]
Nmax=np.where(VG == VGsub[Nsub-1])[0][0]

IDsub=np.zeros(Nsub)
sqrtIDsub=np.zeros(Nsub)

for k in range(0,Nsub):
    IDsub[k]=ID[Nmin+k]
    sqrtIDsub[k]=sqrt(abs(IDsub[k]))

slope, intercept, _, _, _ = linregress(VGsub, sqrtIDsub)
VT0si=-intercept/slope
#display(Latex(f'$V_{{T0,si}}  =$ {VT0si/1e-3:.0f} mV'))

sqrtIDfit=np.zeros(Npts)

for k in range(0,Npts):
    sqrtIDfit[k]=slope*VG[k]+intercept

plt.style.use(pltStyle)
plt.plot(VG,sqrt(abs(ID)),'r-o', markersize=msize, markevery=mevery)
plt.plot(VG,sqrtIDfit,'b--')
plt.xlabel('$V_G$ [V]')
plt.xlim(0,VGmax)
#plt.xticks(np.arange(0,11,1))
plt.ylabel('$\\sqrt{I_D}$ [$\\sqrt{A}$]')
#plt.ylim(0,0.4)
#plt.yticks(np.arange(0,1.1,0.1))
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$V_{{T0}} =$ {VT0si/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.0f}'))
plt.text(1.03, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_long_VT0_average')
plt.show()
```

We can then fit the linear portion of the curve and extract the intersection point on the $V_G$ axis as shown in @fig-sqrtid_vg_vt0_ext_lc0 which results in $V_{T0} =$ `{python} f'{VT0si/1e-3:.0f}'` $mV$. We can check the $I_D$-$V_G$ charactersitic with this extracted threshold voltage in @fig-id_vg_vt0_fit_check_lc0.

```{python}
#| label: fig-id_vg_vt0_fit_check_lc0
#| fig-cap: $I_D$-$V_G$ for the extracted threshold voltage.

n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0
nUT=n*UT
VT0=VT0si

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]
VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idsim=np.zeros(Npts)
idmod=np.zeros(Npts)

for k in range(0,Npts):
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps(vps[k])
    idsim[k]=ID[k]/Ispec

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(9, 3.5), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[0].semilogy(VGT,idmod, 'b-', label='sEKV')
axs[0].set_xlabel('$V_G-V_{T0}$ [V]')
axs[0].set_xlim(-0.4,1.2)
axs[0].set_xticks(np.arange(-0.4,1.4,0.2))
axs[0].set_ylabel('$I_D/I_{spec}$')
axs[0].set_ylim(1e-4,1e3)
axs[0].legend(loc='upper left')
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$V_{{T0}} =$ {VT0/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.0f}'))
axs[0].text(0.65, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[1].plot(VGT,idmod, 'b-', label='sEKV')
axs[1].set_xlabel('$V_G-V_{T0}$ [V]')
axs[1].set_xlim(-0.4,1.2)
axs[1].set_xticks(np.arange(-0.4,1.4,0.2))
axs[1].set_ylabel('$I_D/I_{spec}$')
axs[1].set_ylim(0,)
axs[1].legend(loc='lower right')
axs[1].text(0.05, 0.95, textstr, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

As shown in @fig-id_vg_vt0_fit_check_lc0, we get a less good fit in weak inversion. We therefore keep the value of the threshold voltage extracted in weak inversion, namely $V_{T0} =$ `{python} f'{VT0wi/1e-3:.0f}'` $mV$.

### Summary
The results of the direct extraction method is shown in @fig-summary_direct_ext_lc0, which includes the large-signal $IC = I_D/I_{spec}$ versus $V_G-V_{T0}$ on the left and the small-signal parameters $G_{ms}/G_{spec} = G_m\,n\,U_T/I_{spec}$ versus $IC$ and $G_m\,n\,U_T/I_D$ versus $IC$ on the right. We see a good fit of the large- and small-signal parameters except in very strong inversion (i.e. $100 < IC$). The extracted parameters are summarized in @tbl-sekv_parameters1.

```{python}
#| label: fig-summary_direct_ext_lc0
#| fig-cap: Summary of direct extraction with $\lambda_c = 0$.

n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0
nUT=n*UT
VT0=VT0wi

Npts=len(VG)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)
VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idsim=np.zeros(Npts)
ICsim=np.zeros(Npts)
idmod=np.zeros(Npts)
gmssim=np.zeros(Npts)
gmsmod=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)

for k in range(0,Npts):
    idsim[k]=ID[k]/Ispec
    ICsim[k]=idsim[k]
    gmssim[k]=Gm[k]*nUT/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps_short(vps[k],lambdac)
    gmsmod[k]=gms_ic_short(ICmod[k],lambdac)
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

fig = plt.figure(figsize=(8, 5))
ax1 = fig.add_subplot(2, 2, 1)
ax2 = fig.add_subplot(2, 2, 2)
ax3 = fig.add_subplot(2, 2, 3, sharex = ax1)
ax4 = fig.add_subplot(2, 2, 4, sharex = ax2)

ax1.semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
ax1.semilogy(VGT,idmod, 'b-', label='sEKV')
#ax1.set_xlabel('$V_G-V_{T0}$ [V]')
#ax1.set_xlim(-0.3,0.7)
#ax1.set_xticks(np.arange(-0.3,0.8,0.1))
ax1.set_ylabel('$I_D/I_{spec}$ (log)')
#ax1.set_ylim(1e-4,1e3)
ax1.set_yticks([1e-5,1e-4,1e-3,1e-2,1e-1,1e0,1e1,1e2,1e3])
ax1.legend(loc='upper left')
ax1.tick_params('x', labelbottom=False)
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$V_{{T0}} =$ {VT0/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.0f}'))
ax1.text(0.72, 0.07, mosinfo, ha='left', va='bottom', transform=ax1.transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax2.loglog([1e-3,1],[1,1],'k--', linewidth=lw)
ax2.loglog([1,1e3],[1,sqrt(1e3)],'k--', linewidth=lw)
ax2.loglog([1,1],[1e-3,1],'k--', linewidth=lw)
ax2.loglog([1e-3,1],[1e-3,1],'k--', linewidth=lw)
#ax2.loglog([1e-3,1/lambdac],[1e-3,1/lambdac],'k--', linewidth=lw)
#ax2.loglog([1/lambdac,1/lambdac],[1e-3,1/lambdac],'k--', linewidth=lw)
#ax2.loglog([1e-3,1e3],[1/lambdac,1/lambdac],'k--', linewidth=lw)
#ax2.loglog([1/lambdac**2,1/lambdac**2],[1e-3,1/lambdac],'k--', linewidth=lw)
ax2.loglog(ICsim,gmssim, 'ro', label='Data', markersize=msize, markevery=2)
ax2.loglog(ICmod,gmsmod, 'b-', label='sEKV')
#ax2.set_xlabel('$IC$ [-]')
ax2.set_xlim(ICmin,ICmax)
ax2.set_ylabel('$G_m\\,n\\,U_T/I_{spec}$ [-]')
ax2.set_ylim(1e-3,1e1)
ax2.tick_params('x', labelbottom=False)
ax2.legend(loc='lower right')
#ax2.annotate('$1/\lambda_c =$' + f'{1/lambdac:.1f}', size=9,
#             xy=(1e2, 1/lambdac), xycoords='data',
#             xytext=(25, 0), textcoords='offset points',
#             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
#             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
#             ha='left', va='center')
#ax2.text(0.65, 0.05, textstr, ha='left', va='bottom', transform=ax2.transAxes, size=9,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax3.plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
ax3.plot(VGT,idmod, 'b-', label='sEKV')
ax3.set_xlabel('$V_G-V_{T0}$ [V]')
ax3.set_xlim(-0.4,1.1)
ax3.set_xticks(np.arange(-0.4,1.2,0.2))
ax3.set_ylabel('$I_D/I_{spec}$ (lin)')
ax3.set_ylim(0,200)
ax3.set_yticks(np.arange(0,200,50))
ax3.legend(loc='lower right')
ax3.text(0.05, 0.95, textstr, ha='left', va='top', transform=ax3.transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax4.loglog([1e-3,1],[1,1],'k--', linewidth=lw)
ax4.loglog([1,1e3],[1,1/sqrt(1e3)],'k--', linewidth=lw)
ax4.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
#ax4.loglog([1/lambdac,1e3],[1,1/(lambdac*1e3)],'k--', linewidth=lw)
#ax4.loglog([1/lambdac,1/lambdac],[1e-2,1],'k--', linewidth=lw)
#ax4.loglog([1/lambdac**2,1/lambdac**2],[1e-2,lambdac],'k--', linewidth=lw)
ax4.loglog(ICsim,gmidsim, 'ro', label='Data', markersize=msize, markevery=2)
ax4.loglog(ICmod,gmidmod, 'b-', label='sEKV')
ax4.set_xlabel('$IC$ [-]')
ax4.set_xlim(ICmin,ICmax)
ax4.set_ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
ax4.set_ylim(1e-2,)
ax4.legend(loc='lower left')
#ax4.annotate('$1/\lambda_c =$' + f'{1/lambdac:.1f}', size=9,
#             xy=(1/lambdac, 1e-2), xycoords='data',
#             xytext=(0, -25), textcoords='offset points',
#             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
#             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
#             ha='center', va='top')
#ax4.annotate('$1/\lambda_c^2 =$' + f'{1/lambdac**2:.0f}', size=9,
#             xy=(1/lambdac**2, 1e-2), xycoords='data',
#             xytext=(0, -37), textcoords='offset points',
#             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
#             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
#             ha='center', va='top')
#ax4.text(0.05, 0.05, textstr, ha='left', va='bottom', transform=ax4.transAxes, size=9,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
fig.subplots_adjust(hspace=0)
fig.subplots_adjust(wspace=0.3)
#saveFigures(savePath, '180nm_nMOS_long_direct_summary')
plt.show()
```

```{python}
#| label: tbl-sekv_parameters1
#| tbl-cap: Direct extraction of the sEKV parameters with $\lambda_c=0$.

sekv_idvg_param_df={
    "n": [n],
    "Ispecsq": [Ispecsq/1e-9],
    "VT0": [VT0/1e-3],
    "lambdac": [lambdac],
    "Lsat": [Lsat/1e-9],
    "Comment": "direct with $\\lambda_c = 0$"
}
index_labels=[tYPE]
sekv_idvg_param_df=pd.DataFrame(sekv_idvg_param_df, index=index_labels)

Markdown(tabulate(
  sekv_idvg_param_df,
  headers=["Type","$n$","$I_{{spec\\Box}}\\;[nA]$","$V_{{T0}}\\;[mV]$","$\\lambda_c$","$L_{{sat}}\\;[nm]$","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center","center","center"),
  floatfmt=(".0f",".2f",".0f",".0f",".0f",".0f")
))
```

We now will use the VS $\lambda_c$ to get a better fit in strong inversion.

## Direct extraction with $\lambda_c > 0$
### Slope factor $n$ extraction
Proceeding in the same way as above, we can extract the slope factor $n$ from the characteristic shown in @fig-slope_ext.

```{python}
#| label: fig-slope_ext
#| fig-cap: Slope factor extraction.

Npts=len(VG)
next=np.zeros(Npts)

for k in range(0,Npts):
    next[k]=ID[k]/(Gm[k]*UT)

nextmin=np.min(next)
Nmin=np.where(next == nextmin)[0]
IDext=ID[Nmin[0]]
n0=round(nextmin,2)

plt.style.use(pltStyle)
plt.loglog(ID,next,'r-o', markersize=msize, markevery=mevery)
plt.loglog([1e-12,IDext],[n0,n0],'k--', linewidth=lw)
plt.loglog([IDext,IDext],[1,n0],'k--', linewidth=lw)
plt.loglog(ID[Nmin],next[Nmin],'ko', markersize=5)
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.xlabel('$I_D$ [A]')
plt.ylim(1,1e2)
plt.ylabel('$I_D/(G_m\\,U_T)$ [-]')
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.annotate(f'$n =$ {n0:.2f}', size=9,
             xy=(1e-10, n0), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate(f'$I_D =$ {IDext/1e-9:.0f} nA', size=9,
             xy=(IDext, n0), xycoords='data',
             xytext=(0, 30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='bottom')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n0:.2f}'))
plt.text(0.03, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_short_n_direct')
plt.show()
```

We get the same value as before namely $n =$ `{python} f'{n0:.2f}'`.

### Specific current $I_{spec}$ extraction
The specific current is extracted as above from the characteristic shown in @fig-ispec_ext.

```{python}
#| label: fig-ispec_ext
#| fig-cap: $I_{spec}$ extraction.

Ispecext=np.zeros(Npts)
nUT=n0*UT

for k in range(0,Npts):
    Ispecext[k]=(Gm[k]*nUT)**2/ID[k]

Ispec0=np.max(Ispecext)
Ispecsq0=Ispec0/(Weff/Leff)
Nmax=np.where(Ispecext == Ispec0)[0]
IDext=ID[Nmax[0]]

plt.style.use(pltStyle)
plt.loglog(ID,Ispecext,'r-o', markersize=msize, markevery=mevery)
plt.loglog([1e-12,IDext],[Ispec0,Ispec0],'k--', linewidth=lw)
plt.loglog([IDext,IDext],[1e-12,Ispec0],'k--', linewidth=lw)
plt.loglog(ID[Nmax],Ispecext[Nmax],'ko', markersize=5)
plt.xlabel('$I_D$ [A]')
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.ylabel('$(G_m\\,n\\,U_T)^2/I_D$ [A]')
plt.ylim(1e-10,1e-4)
plt.annotate(f'$I_{{spec}} =$ {Ispec0/1e-6:.2f} $\\mu A$', size=9,
             xy=(1e-10, Ispec0), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate(f'$I_D =$ {IDext/1e-6:.2f} $\\mu A$', size=9,
             xy=(IDext, 1e-10), xycoords='data',
             xytext=(0, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n0:.2f}',
    f'$I_{{spec}} =$ {Ispec0/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq0/1e-9:.0f} nA'))
plt.text(0.5, 0.05, textstr, ha='left', va='bottom', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_short_Ispec_direct')
plt.show()
```

We of course get the same value as before, namely $I_{spec} =$ `{python} f'{Ispec0/1e-6:.2f}'` $\mu A$ corresponding to $I_{spec\Box} =$ `{python} f'{Ispecsq0/1e-9:.0f}'` $nA$. We can the plot $I_D/(G_m\,U_T)$ as shown in @fig-idgm_id_n_ispec_check. We see that the asymptote are correct except in strong inversion where the curve is steeper. This can then be handled by the additional VS parameter $\lambda_c$.

```{python}
#| label: fig-idgm_id_n_ispec_check
#| fig-cap: $n$ and $I_{spec}$ check.

#The values of n, Ispecsq, Ispec are updated to the extracted values n0, Ispecsq0 and Ispec
#in order to keep always the same script for the plots that are not related to an extraction
n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0

Next=101
IDsi=np.linspace(Ispec0,1e-2,Next,endpoint=True)
IDGmUTsi=np.zeros(Next)

for k in range(0,Next):
    IDGmUTsi[k]=n*sqrt(IDsi[k]/Ispec)

plt.style.use(pltStyle)
plt.loglog(ID,next,'r-o', markersize=5, markevery=4)
plt.loglog(IDsi,IDGmUTsi,'k--', linewidth=lw)
plt.loglog([1e-10,Ispec],[n,n],'k--', linewidth=lw)
plt.loglog([Ispec,Ispec],[1,n],'k--', linewidth=lw)
plt.xlabel('$I_D$ [A]')
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.ylabel('$I_D/(G_m\\,U_T)$ [-]')
plt.ylim(1,1e2)
plt.annotate(f'$n =$ {n:.2f}', size=9,
             xy=(1e-10, n), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate(f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$', size=9,
             xy=(Ispec, 1), xycoords='data',
             xytext=(15, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA'))
plt.text(0.03, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

### Velocity saturation parameter $\lambda_c$ extraction
We can extract $\lambda_c$ by looking at the asymptote in very strong inversion. For a short-channel transistor in strong inversion and saturation, the normalized $G_m/I_D$ is given by @bib:enz:book:2006
\begin{equation}
  \frac{G_m\,n\,U_T}{I_D} = \frac{1}{\lambda_c \, IC} = \frac{I_{spec}}{\lambda_c \, I_D}.
\end{equation}
So if we plot $I_{spec}/(G_m\,n\,U_T)$ it will have a minimum at $\lambda_c$ as illustrated in @fig-ispecgm_id_ext.

```{python}
#| label: fig-ispecgm_id_ext
#| fig-cap: Extraction of $\lambda_c$.

n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0

lambdacext=np.zeros(Npts)

for k in range(0,Npts):
    lambdacext[k]=Ispec/(Gm[k]*nUT)

lambdac0=np.min(lambdacext)
Lsat0=lambdac0*Leff
Nmax=np.where(lambdacext == lambdac0)[0]
IDext=ID[Nmax[0]]

plt.style.use(pltStyle)
plt.loglog(ID,lambdacext,'r-o', markersize=msize, markevery=mevery)
plt.loglog([1e-10,IDext],[lambdac0,lambdac0],'k--', linewidth=lw)
plt.loglog([IDext,IDext],[1e-1,lambdac0],'k--', linewidth=lw)
plt.loglog(ID[Nmax],lambdacext[Nmax],'ko', markersize=5)
plt.xlabel('$I_D$ [A]')
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.ylabel('$I_{spec}/(G_m\\,n\\,U_T)$ [-]')
plt.ylim(1e-2,1e5)
plt.annotate(f'$\\lambda_c =$ {lambdac0:.3f}', size=9,
             xy=(1e-10, lambdac0), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate(f'$I_D =$ {IDext/1e-3:.1f} mA', size=9,
             xy=(IDext, 1e-1), xycoords='data',
             xytext=(0, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$\\lambda_c =$ {lambdac0:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
plt.text(1.05, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_short_lambdac_direct')
plt.show()
```

This results in $\lambda_c =$ `{python} f'{lambdac0:.3f}'` corresponding to $L_{sat} =$ `{python} f'{Lsat0/1e-9:.2f}'` $nm$. We can now add the strong inversion asymptote on the $I_D/(G_m\,n\,U_T)$ versus $I_D$ characteristic as shown in @fig-idgm_id_n_ispec_lambdac_check.

```{python}
#| label: fig-idgm_id_n_ispec_lambdac_check
#| fig-cap: $n$, $I_{spec}$ and $\lambda_x$ check.

#The values of n, Ispecsq, Ispec are updated to the extracted values n0, Ispecsq0 and Ispec
#in order to keep always the same script for the plots that are not related to an extraction
n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0
lambdac=lambdac0
Lsat=Lsat0

Next=101
IDsi=np.linspace(Ispec,1e-2,Next,endpoint=True)
IDGmUTsi=np.zeros(Next)
IDGmUTvs=np.zeros(Next)

for k in range(0,Next):
    IDGmUTsi[k]=n*sqrt(IDsi[k]/Ispec)
    IDGmUTvs[k]=n*lambdac*IDsi[k]/Ispec

plt.style.use(pltStyle)
plt.loglog(ID,next,'r-o', markersize=msize, markevery=mevery)
plt.loglog(IDsi,IDGmUTsi,'k--', linewidth=lw)
plt.loglog(IDsi,IDGmUTvs,'k--', linewidth=lw)
plt.loglog([1e-10,Ispec],[n,n],'k--', linewidth=lw)
plt.loglog([Ispec,Ispec],[1,n],'k--', linewidth=lw)
plt.xlabel('$I_D$ [A]')
plt.xlim(1e-10,1e-2)
plt.xticks([1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3,1e-2])
plt.ylabel('$I_D/(G_m\\,U_T)$ [-]')
plt.ylim(1,1e2)
plt.annotate(f'$n =$ {n:.2f}', size=9,
             xy=(1e-10, n), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
plt.annotate(f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$', size=9,
             xy=(Ispec, 1), xycoords='data',
             xytext=(15, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$\\lambda_c =$ {lambdac0:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
plt.text(0.03, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_short_n_Ispec_lambdac')
plt.show()
```

We can also check the normalized $G_m/I_D$ characteristic which is plotted in @fig-gmid_ic_n_ispec_lambdac_check.

```{python}
#| label: fig-gmid_ic_n_ispec_lambdac_check
#| fig-cap: Check of the normalized $G_m/I_D$ for $n$, $I_{spec}$ and $\lambda_c$.

n=n0
Ispecsq=Ispecsq0
Ispec=Ispec0
lambdac=lambdac0
Lsat=Lsat0

ICsim=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)

for k in range(0,Npts):
    ICsim[k]=ID[k]/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

plt.style.use(pltStyle)
plt.loglog([1e-3,1/lambdac],[1,1],'k--', linewidth=lw)
plt.loglog([1,1e3],[1,1/sqrt(1e3)],'k--', linewidth=lw)
plt.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
plt.loglog([1/lambdac,1e3],[1,1/(lambdac*1e3)],'k--', linewidth=lw)
plt.loglog([1/lambdac,1/lambdac],[1e-2,1],'k--', linewidth=lw)
plt.loglog([1/lambdac**2,1/lambdac**2],[1e-2,lambdac],'k--', linewidth=lw)
plt.loglog(ICsim,gmidsim,'ro', markersize=msize, markevery=2)
plt.loglog(ICmod,gmidmod,'b-')
plt.xlim(1e-3,1e3)
#plt.xticks(np.arange(0,11,1))
plt.xlabel('$IC$ [-]')
plt.ylim(1e-2,)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.annotate(f'$1/\\lambda_c =$ {1/lambdac:.1f}', size=9,
             xy=(1/lambdac, 1e-2), xycoords='data',
             xytext=(10, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
plt.annotate(f'$1/\\lambda_c^2 =$ {1/lambdac**2:.0f}', size=9,
             xy=(1/lambdac**2, 1e-2), xycoords='data',
             xytext=(25, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
plt.text(0.03, 0.05, textstr, ha='left', va='bottom', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_short_GmID_IC_direct')
plt.show()
```

The fit is OK at the asymptotes but not good in the moderate and strong inversion regions. We can try to increase $I_{spec}$ and $\lambda_c$ in order to have a better fit in moderate and strong inversion as illustrated in @fig-gmid_ic_n_ispec_lambdac_tuning.

```{python}
#| label: fig-gmid_ic_n_ispec_lambdac_tuning
#| fig-cap: Tuning of $I_{spec}$ and $\lambda_c$ on the normalized $G_m/I_D$.

n=n0
#Ispecsq=Ispecsq0
Ispecsq=500e-9
Ispec=Ispecsq*Weff/Leff
#lambdac=lambdac0
lambdac=0.12

ICsim=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)

for k in range(0,Npts):
    ICsim[k]=ID[k]/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

plt.style.use(pltStyle)
plt.loglog([1e-3,1/lambdac],[1,1],'k--', linewidth=lw)
plt.loglog([1,1e3],[1,1/sqrt(1e3)],'k--', linewidth=lw)
plt.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
plt.loglog([1/lambdac,1e3],[1,1/(lambdac*1e3)],'k--', linewidth=lw)
plt.loglog([1/lambdac,1/lambdac],[1e-2,1],'k--', linewidth=lw)
plt.loglog([1/lambdac**2,1/lambdac**2],[1e-2,lambdac],'k--', linewidth=lw)
plt.loglog(ICsim,gmidsim,'ro', markersize=msize, markevery=2)
plt.loglog(ICmod,gmidmod,'b-')
plt.xlim(1e-3,1e3)
#plt.xticks(np.arange(0,11,1))
plt.xlabel('$IC$ [-]')
plt.ylim(1e-2,)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.annotate(f'$1/\\lambda_c =$ {1/lambdac:.1f}', size=9,
             xy=(1/lambdac, 1e-2), xycoords='data',
             xytext=(20, -40), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
plt.annotate(f'$1/\\lambda_c^2 =$ {1/lambdac**2:.0f}', size=9,
             xy=(1/lambdac**2, 1e-2), xycoords='data',
             xytext=(40, -40), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
plt.text(0.03, 0.05, textstr, ha='left', va='bottom', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#saveFigures(savePath, '180nm_nMOS_short_GmID_IC_direct_tuned')
plt.show()
```

The fit is now much better from weak to strong inversion.

### Threshold voltage extraction
We now extract the threshold voltage in the same way as above, first plotting $V_{T0ext}$ versus $V_G$ as shown in fig-vt0ext_vg.

```{python}
#| label: fig-vt0ext_vg
#| fig-cap: Threshold voltage extraction.

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]

ICsim=np.zeros(Npts)
VT0ext=np.zeros(Npts)

nUT=n*UT

for k in range(0,Npts):
    ICsim[k]=ID[k]/Ispec
    VT0ext[k]=VG[k]-nUT*ln(ICsim[k])

plt.style.use(pltStyle)
plt.plot(VG,VT0ext,'r-o', markersize=msize, markevery=mevery)
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin,VGmax)
#plt.xticks(np.arange(0,2.2,0.2))
plt.ylabel('$V_{T0ext}$ [V]')
#plt.ylim(0,2)
#plt.yticks(np.arange(0,1.1,0.1))
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
plt.text(0.05, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

```{python}
#| label: fig-vt0ext_vg_wi
#| fig-cap: Threshold voltage extraction in weak inversion.

VGmin=0
VGmax=0.34
VGsub=VG[(VG >= VGmin) & (VG <= VGmax)]
Nsub=len(VGsub)
Nmin=np.where(VG == VGsub[0])[0][0]
Nmax=np.where(VG == VGsub[Nsub-1])[0][0]

ICsub=np.zeros(Nsub)
VT0sub=np.zeros(Nsub)

for k in range(0,Nsub):
    ICsub[k]=ID[Nmin+k]/Ispec0
    VT0sub[k]=VGsub[k]-nUT*ln(ICsub[k])

VT0wi=np.mean(VT0sub)

plt.style.use(pltStyle)
plt.plot(VGsub,VT0sub,'r-o', markersize=msize, markevery=1)
plt.plot([VGmin,VGmax],[VT0wi,VT0wi], 'k--')
plt.xlabel('$V_G$ [V]')
plt.xlim(VGmin,VGmax)
#plt.xticks(np.arange(0,11,1))
plt.ylabel('$V_{T0ext}$ [V]')
plt.ylim(0,0.5)
#plt.yticks(np.arange(0,1.1,0.1))
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.annotate(f'$V_{{T0}} =$ {VT0wi:.3f}', size=9,
             xy=(VGmin, VT0wi), xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='center')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$V_{{T0}} =$ {VT0wi/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
plt.text(1.05, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

Averaging the threshold voltage in the range it is about constant results in $V_{T0} =$ `{python} f'{VT0wi/1e-3:.0f}'` $mV$ which is slightly lower than the value extracted with $\lambda_c = 0$. We can now check the $I_D$-$V_G$ curves which are shown in @fig-id_vg_vt0_check.

```{python}
#| label: fig-id_vg_vt0_check
#| fig-cap: $I_D$-$V_G$ for the extracted parameters.

VT0=VT0wi

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]
VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idsim=np.zeros(Npts)
idmod=np.zeros(Npts)

for k in range(0,Npts):
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps_short(vps[k],lambdac)
    idsim[k]=ID[k]/Ispec

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(9, 3.5), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[0].semilogy(VGT,idmod, 'b-', label='sEKV')
axs[0].set_xlabel('$V_G-V_{T0}$ [V]')
axs[0].set_xlim(-0.4,1.2)
axs[0].set_xticks(np.arange(-0.4,1.4,0.2))
axs[0].set_ylabel('$I_D/I_{spec}$')
axs[0].set_ylim(1e-5,1e3)
axs[0].legend(loc='upper left')
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$V_{{T0}} =$ {VT0/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
axs[0].text(0.65, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[1].plot(VGT,idmod, 'b-', label='sEKV')
axs[1].set_xlabel('$V_G-V_{T0}$ [V]')
axs[1].set_xlim(-0.4,1.2)
axs[1].set_xticks(np.arange(-0.4,1.4,0.2))
axs[1].set_ylabel('$I_D/I_{spec}$')
axs[1].set_ylim(0,)
axs[1].legend(loc='lower right')
axs[1].text(0.05, 0.95, textstr, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

We see that the threshold voltage is too low. We can fine tune it manually as illustrated in @fig-id_vg_vt0_tuning.

```{python}
#| label: fig-id_vg_vt0_tuning
#| fig-cap: $I_D$-$V_G$ for the extracted parameters.

#Ispecsq=1.1e-6
#Ispec=Ispecsq*W/L
VT0=0.418
lambdac=0.12

Npts=len(VG)
VGmin=VG[0]
VGmax=VG[Npts-1]
VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idsim=np.zeros(Npts)
idmod=np.zeros(Npts)

for k in range(0,Npts):
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps_short(vps[k],lambdac)
    idsim[k]=ID[k]/Ispec

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(9, 3.5), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[0].semilogy(VGT,idmod, 'b-', label='sEKV')
axs[0].set_xlabel('$V_G-V_{T0}$ [V]')
axs[0].set_xlim(-0.4,1.2)
axs[0].set_xticks(np.arange(-0.4,1.4,0.2))
axs[0].set_ylabel('$I_D/I_{spec}$')
axs[0].set_ylim(1e-5,1e3)
axs[0].legend(loc='upper left')
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$V_{{T0}} =$ {VT0/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
axs[0].text(0.65, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[1].plot(VGT,idmod, 'b-', label='sEKV')
axs[1].set_xlabel('$V_G-V_{T0}$ [V]')
axs[1].set_xlim(-0.4,1.2)
axs[1].set_xticks(np.arange(-0.4,1.4,0.2))
axs[1].set_ylabel('$I_D/I_{spec}$')
axs[1].set_ylim(0,)
axs[1].legend(loc='lower right')
axs[1].text(0.05, 0.95, textstr, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

With $V_{T0} =$ `{python} f'{VT0/1e-3:.0f}'` $mV$, we now have a very good fit of the $I_D$-$V_G$ characteristic in the entire range of $V_G-V_{T0}$, from weak to strong inversion.

### Summary
We results of the direct extraction with $\lambda_c > 0$ are summarized in @fig-summary_direct_ext for the sEKV parameters presented in @tbl-sekv_parameters2.

```{python}
#| label: fig-summary_direct_ext
#| fig-cap: Summary of the direct extraction with $\lambda_c > 0$.

#Ispecsq=457e-9
#Ispec=Ispecsq*Weff/Leff
#lambdac=0.16

Npts=len(VG)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)
VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idsim=np.zeros(Npts)
ICsim=np.zeros(Npts)
idmod=np.zeros(Npts)
gmssim=np.zeros(Npts)
gmsmod=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)

for k in range(0,Npts):
    idsim[k]=ID[k]/Ispec
    ICsim[k]=idsim[k]
    gmssim[k]=Gm[k]*nUT/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps_short(vps[k],lambdac)
    gmsmod[k]=gms_ic_short(ICmod[k],lambdac)
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

fig = plt.figure(figsize=(8, 5))
ax1 = fig.add_subplot(2, 2, 1)
ax2 = fig.add_subplot(2, 2, 2)
ax3 = fig.add_subplot(2, 2, 3, sharex = ax1)
ax4 = fig.add_subplot(2, 2, 4, sharex = ax2)

ax1.semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
ax1.semilogy(VGT,idmod, 'b-', label='sEKV')
#ax1.set_xlabel('$V_G-V_{T0}$ [V]')
#ax1.set_xlim(-0.3,0.7)
#ax1.set_xticks(np.arange(-0.3,0.8,0.1))
ax1.set_ylabel('$I_D/I_{spec}$ (log)')
#ax1.set_ylim(1e-6,1e2)
#ax1.set_yticks([1e-6,1e-5,1e-4,1e-3,1e-2,1e-1,1e0,1e1,1e2])
ax1.legend(loc='upper left')
ax1.tick_params('x', labelbottom=False)
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$V_{{T0}} =$ {VT0/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat0/1e-9:.2f} nm'))
ax1.text(0.72, 0.05, mosinfo, ha='left', va='bottom', transform=ax1.transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax2.loglog([1e-3,1],[1,1],'k--', linewidth=lw)
ax2.loglog([1,1e3],[1,sqrt(1e3)],'k--', linewidth=lw)
ax2.loglog([1,1],[1e-3,1],'k--', linewidth=lw)
ax2.loglog([1e-3,1],[1e-3,1],'k--', linewidth=lw)
ax2.loglog([1e-3,1/lambdac],[1e-3,1/lambdac],'k--', linewidth=lw)
ax2.loglog([1/lambdac,1/lambdac],[1e-3,1/lambdac],'k--', linewidth=lw)
ax2.loglog([1e-3,1e3],[1/lambdac,1/lambdac],'k--', linewidth=lw)
ax2.loglog([1/lambdac**2,1/lambdac**2],[1e-3,1/lambdac],'k--', linewidth=lw)
ax2.loglog(ICsim,gmssim, 'ro', label='Data', markersize=msize, markevery=2)
ax2.loglog(ICmod,gmsmod, 'b-', label='sEKV')
#ax2.set_xlabel('$IC$ [-]')
ax2.set_xlim(ICmin,ICmax)
ax2.set_ylabel('$G_m\\,n\\,U_T/I_{spec}$ [-]')
ax2.set_ylim(1e-3,1e1)
ax2.tick_params('x', labelbottom=False)
ax2.legend(loc='lower right')
ax2.annotate(f'$1/\\lambda_c =$ {1/lambdac:.1f}', size=9,
             xy=(1e3, 1/lambdac), xycoords='data',
             xytext=(25, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='left', va='center')
#ax2.text(0.65, 0.05, textstr, ha='left', va='bottom', transform=ax2.transAxes, size=9,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax3.plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
ax3.plot(VGT,idmod, 'b-', label='sEKV')
ax3.set_xlabel('$V_G-V_{T0}$ [V]')
ax3.set_xlim(-0.4,1.2)
ax3.set_xticks(np.arange(-0.4,1.4,0.2))
ax3.set_ylabel('$I_D/I_{spec}$ (lin)')
#ax3.set_ylim(0,50)
#ax3.set_yticks(np.arange(0,50,10))
ax3.legend(loc='lower right')
ax3.text(0.05, 0.95, textstr, ha='left', va='top', transform=ax3.transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax4.loglog([1e-3,1/lambdac],[1,1],'k--', linewidth=lw)
ax4.loglog([1,1e3],[1,1/sqrt(1e3)],'k--', linewidth=lw)
ax4.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
ax4.loglog([1/lambdac,1e3],[1,1/(lambdac*1e3)],'k--', linewidth=lw)
ax4.loglog([1/lambdac,1/lambdac],[1e-2,1],'k--', linewidth=lw)
ax4.loglog([1/lambdac**2,1/lambdac**2],[1e-2,lambdac],'k--', linewidth=lw)
ax4.loglog(ICsim,gmidsim, 'ro', label='Data', markersize=msize, markevery=2)
ax4.loglog(ICmod,gmidmod, 'b-', label='sEKV')
ax4.set_xlabel('$IC$ [-]')
ax4.set_xlim(1e-3,1e3)
ax4.set_ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
ax4.set_ylim(1e-2,)
ax4.legend(loc='lower left')
ax4.annotate(f'$1/\\lambda_c =$ {1/lambdac:.1f}', size=9,
             xy=(1/lambdac, 1e-2), xycoords='data',
             xytext=(0, -25), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
ax4.annotate(f'$1/\\lambda_c^2 =$ {1/lambdac**2:.0f}', size=9,
             xy=(1/lambdac**2, 1e-2), xycoords='data',
             xytext=(0, -37), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
#ax4.text(0.05, 0.05, textstr, ha='left', va='bottom', transform=ax4.transAxes, size=9,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
fig.subplots_adjust(hspace=0)
fig.subplots_adjust(wspace=0.3)
#saveFigures(savePath, '180nm_nMOS_short_direct_summary')
plt.show()
```

We finally get a reasonable fit of all characteristics.

```{python}
#| label: tbl-sekv_parameters2
#| tbl-cap: Extraction of the sEKV parameters using direct extraction with $\lambda_c > 0$.

sekv_idvg_param_df.loc[len(sekv_idvg_param_df.index)] = [n,Ispecsq/1e-9,VT0/1e-3,lambdac,Lsat/1e-9,"direct with $\\lambda_c > 0$"]
sekv_idvg_param_df = sekv_idvg_param_df.rename(index={1: tYPE})

Markdown(tabulate(
  sekv_idvg_param_df,
  headers=["Type","$n$","$I_{{spec\\Box}}\\;[nA]$","$V_{{T0}}\\;[mV]$","$\\lambda_c$","$L_{{sat}}\\;[nm]$","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center","center","center"),
  floatfmt=(".0f",".2f",".0f",".0f",".2f",".2f")
))
```

## Extraction using curve fitting
### Specific current $I_{spec}$ and $\lambda_c$ extraction
We can extract the slope factor $n$, the specific current $I_{spec}$ and the velocity saturation parameter $\lambda_c$ on the normalized $G_m/I_D$ versus $IC$ characteristic using curve-fitting. The result is shown in @fig-n_ispec_lambdac_ext_opt.

```{python}
#| label: fig-n_ispec_lambdac_ext_opt
#| fig-cap: Extraction of $n$, $I_{spec}$ and $\lambda_c$ by curve fitting.

# Import curve fitting package from scipy
from scipy.optimize import curve_fit

def GmIDfit4(ID,n,Ispec,lambdac):
    nUT=n*UT
    IC=ID/Ispec
    gmsid=gmsid_ic_short(IC,lambdac)
    return gmsid/nUT

Npts=len(VG)
GmIDsim=np.zeros(Npts)

for k in range(0,Npts):
    GmIDsim[k]=Gm[k]/ID[k]

nini=n0
Ispecini=Ispec0
lambdacini=0.1

pars, cov = curve_fit(f=GmIDfit4, xdata=ID, ydata=GmIDsim, p0=[nini,Ispecini,lambdacini], )
n4=pars[0]
Ispec4=pars[1]
lambdac4=pars[2]
Ispecsq4=Ispec4/(Weff/Leff)
Lsat4=lambdac4*Leff

n=n4
Ispecsq=Ispecsq4
Ispec=Ispec4
lambdac=lambdac4
Lsat=Lsat4

ICsim=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)

for k in range(0,Npts):
    ICsim[k]=ID[k]/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

plt.style.use(pltStyle)
plt.loglog([1e-3,1/lambdac],[1,1],'k--', linewidth=lw)
plt.loglog([1,1e3],[1,1/sqrt(1e3)],'k--', linewidth=lw)
plt.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
plt.loglog([1/lambdac,1e3],[1,1/(lambdac*1e3)],'k--', linewidth=lw)
plt.loglog([1/lambdac,1/lambdac],[1e-2,1],'k--', linewidth=lw)
plt.loglog([1/lambdac**2,1/lambdac**2],[1e-2,lambdac],'k--', linewidth=lw)
plt.loglog(ICsim,gmidsim,'ro', markersize=msize, markevery=2)
plt.loglog(ICmod,gmidmod,'b-')
plt.xlim(1e-3,1e3)
#plt.xticks(np.arange(0,11,1))
plt.xlabel('$IC$ [-]')
plt.ylim(1e-2,)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
#plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.annotate(f'$1/\\lambda_c =$ {1/lambdac:.1f}', size=9,
             xy=(1/lambdac, 1e-2), xycoords='data',
             xytext=(0, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
plt.annotate(f'$1/\\lambda_c^2 =$ {1/lambdac**2:.0f}', size=9,
             xy=(1/lambdac**2, 1e-2), xycoords='data',
             xytext=(0, -40), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
textstr = '\n'.join((
    mosinfo,
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.1f} $\\mu A$',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat/1e-9:.2f} nm'))
plt.text(0.03, 0.05, textstr, ha='left', va='bottom', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

We get a good fit across all regions with similar values than the one obtained in the direct extraction methodology.

### Threshold voltage extraction
We can also extract the threshold voltage from the $I_D$-$V_G$ charactersitic as illustrated in @fig-vt0_ext_opt.

```{python}
#| label: fig-vt0_ext_opt
#| fig-cap: Threshold voltage extraction.

# Import curve fitting package from scipy
from scipy.optimize import curve_fit

def logIDVGfit2(VG,VT0):
    vps=(VG-VT0)/nUT
    IC=ic_vps_lambert(vps,lambdac)
    return ln(IC)

idsim=np.zeros(Npts)
logidsim=np.zeros(Npts)

for k in range(0,Npts):
    idsim[k]=ID[k]/Ispec4
    logidsim[k]=ln(idsim[k])

nUT=n*UT
VT0ini=0.4
    
pars, cov = curve_fit(f=logIDVGfit2, xdata=VG, ydata=logidsim, p0=VT0ini)
VT04=pars[0]

VT0=VT04

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(9, 3.5), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idmod=np.zeros(Npts)

for k in range(0,Npts):
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps_lambert(vps[k],lambdac)

axs[0].semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[0].semilogy(VGT,idmod, 'b-', label='sEKV')
axs[0].set_xlabel('$V_G-V_{T0}$ [V]')
axs[0].set_xlim(-0.5,)
axs[0].set_ylabel('$I_D/I_{spec}$')
#axs[0].set_ylim(1e-5,1e3)
axs[0].legend(loc='upper left')
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$V_{{T0}} =$ {VT0:.3f} V',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat/1e-9:.2f} nm'))
axs[0].text(0.65, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
axs[1].plot(VGT,idmod, 'b-', label='sEKV')
axs[1].set_xlabel('$V_G-V_{T0}$ [V]')
axs[1].set_xlim(-0.5,)
axs[1].set_ylabel('$I_D/I_{spec}$')
axs[1].set_ylim(0,)
axs[1].legend(loc='lower right')
axs[1].text(0.05, 0.95, textstr, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

This results in $V_{T0} =$ `{python} f'{VT0/1e-3:.0f}'` $mV$ which is close to what was obtained with the direct extraction. @fig-vt0_ext_opt shows that curve fitting can result in a very good fit in all regions of operation!

### Summary
The result of the curve fitting extraction methodology is summarized in @fig-summary_opt_ext_lc with the paramters given in @tbl-sekv_parameters3. We see that we obtained an overall good fit in all regions of operation.

```{python}
#| label: fig-summary_opt_ext_lc
#| fig-cap: Summary of extraction by curve fitting for the long-channel.

Npts=len(VG)
logICmin=-3
logICmax=3
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICmod=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)
VGT=np.zeros(Npts)
vps=np.zeros(Npts)
idsim=np.zeros(Npts)
ICsim=np.zeros(Npts)
idmod=np.zeros(Npts)
gmssim=np.zeros(Npts)
gmsmod=np.zeros(Npts)
gmidsim=np.zeros(Npts)
gmidmod=np.zeros(Npts)

for k in range(0,Npts):
    idsim[k]=ID[k]/Ispec
    ICsim[k]=idsim[k]
    gmssim[k]=Gm[k]*nUT/Ispec
    gmidsim[k]=Gm[k]*nUT/ID[k]
    VGT[k]=VG[k]-VT0
    vps[k]=VGT[k]/nUT
    idmod[k]=ic_vps_lambert(vps[k],lambdac)
    gmsmod[k]=gms_ic_short(ICmod[k],lambdac)
    gmidmod[k]=gmsid_ic_short(ICmod[k],lambdac)

fig = plt.figure(figsize=(8, 5))
ax1 = fig.add_subplot(2, 2, 1)
ax2 = fig.add_subplot(2, 2, 2)
ax3 = fig.add_subplot(2, 2, 3, sharex = ax1)
ax4 = fig.add_subplot(2, 2, 4, sharex = ax2)

ax1.semilogy(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
ax1.semilogy(VGT,idmod, 'b-', label='sEKV')
#ax1.set_xlabel('$V_G-V_{T0}$ [V]')
#ax1.set_xlim(-0.3,0.7)
#ax1.set_xticks(np.arange(-0.3,0.8,0.1))
ax1.set_ylabel('$I_D/I_{spec}$ (log)')
#ax1.set_ylim(1e-6,1e2)
#ax1.set_yticks([1e-6,1e-5,1e-4,1e-3,1e-2,1e-1,1e0,1e1,1e2])
ax1.legend(loc='upper left')
ax1.tick_params('x', labelbottom=False)
textstr = '\n'.join((
    f'$n =$ {n:.2f}',
    f'$I_{{specsq}} =$ {Ispecsq/1e-9:.0f} nA',
    f'$I_{{spec}} =$ {Ispec/1e-6:.2f} $\\mu A$',
    f'$V_{{T0}} =$ {VT0/1e-3:.0f} mV',
    f'$\\lambda_c =$ {lambdac:.3f}',
    f'$L_{{sat}} =$ {Lsat/1e-9:.2f} nm'))
ax1.text(0.72, 0.05, mosinfo, ha='left', va='bottom', transform=ax1.transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax2.loglog([1e-3,1],[1,1],'k--', linewidth=lw)
ax2.loglog([1,1e3],[1,sqrt(1e3)],'k--', linewidth=lw)
ax2.loglog([1,1],[1e-3,1],'k--', linewidth=lw)
ax2.loglog([1e-3,1],[1e-3,1],'k--', linewidth=lw)
ax2.loglog([1e-3,1/lambdac],[1e-3,1/lambdac],'k--', linewidth=lw)
ax2.loglog([1/lambdac,1/lambdac],[1e-3,1/lambdac],'k--', linewidth=lw)
ax2.loglog([1e-3,1e3],[1/lambdac,1/lambdac],'k--', linewidth=lw)
ax2.loglog([1/lambdac**2,1/lambdac**2],[1e-3,1/lambdac],'k--', linewidth=lw)
ax2.loglog(ICsim,gmssim, 'ro', label='Data', markersize=msize, markevery=2)
ax2.loglog(ICmod,gmsmod, 'b-', label='sEKV')
#ax2.set_xlabel('$IC$ [-]')
ax2.set_xlim(ICmin,ICmax)
ax2.set_ylabel('$G_m\\,n\\,U_T/I_{spec}$ [-]')
ax2.set_ylim(1e-3,1e1)
ax2.tick_params('x', labelbottom=False)
ax2.legend(loc='lower right')
ax2.annotate(f'$1/\\lambda_c =$ {1/lambdac:.1f}', size=9,
             xy=(1e3, 1/lambdac), xycoords='data',
             xytext=(25, 0), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='left', va='center')
#ax2.text(0.65, 0.05, textstr, ha='left', va='bottom', transform=ax2.transAxes, size=9,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax3.plot(VGT,idsim, 'ro', label='Data', markersize=msize, markevery=mevery)
ax3.plot(VGT,idmod, 'b-', label='sEKV')
ax3.set_xlabel('$V_G-V_{T0}$ [V]')
ax3.set_xlim(-0.4,1.2)
ax3.set_xticks(np.arange(-0.4,1.4,0.2))
ax3.set_ylabel('$I_D/I_{spec}$ (lin)')
ax3.set_ylim(0,)
#ax3.set_yticks(np.arange(0,50,10))
ax3.legend(loc='lower right')
ax3.text(0.05, 0.95, textstr, ha='left', va='top', transform=ax3.transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax4.loglog([1e-3,1/lambdac],[1,1],'k--', linewidth=lw)
ax4.loglog([1,1e3],[1,1/sqrt(1e3)],'k--', linewidth=lw)
ax4.loglog([1,1],[1e-2,1],'k--', linewidth=lw)
ax4.loglog([1/lambdac,1e3],[1,1/(lambdac*1e3)],'k--', linewidth=lw)
ax4.loglog([1/lambdac,1/lambdac],[1e-2,1],'k--', linewidth=lw)
ax4.loglog([1/lambdac**2,1/lambdac**2],[1e-2,lambdac],'k--', linewidth=lw)
ax4.loglog(ICsim,gmidsim, 'ro', label='Data', markersize=msize, markevery=2)
ax4.loglog(ICmod,gmidmod, 'b-', label='sEKV')
ax4.set_xlabel('$IC$ [-]')
ax4.set_xlim(1e-3,1e3)
ax4.set_ylabel('$G_m\\,n\\,U_T/I_D$ [-]')
ax4.set_ylim(1e-2,)
ax4.legend(loc='lower left')
ax4.annotate(f'$1/\\lambda_c =$ {1/lambdac:.1f}', size=9,
             xy=(1/lambdac, 1e-2), xycoords='data',
             xytext=(0, -25), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
ax4.annotate(f'$1/\\lambda_c^2 =$ {1/lambdac**2:.0f}', size=9,
             xy=(1/lambdac**2, 1e-2), xycoords='data',
             xytext=(0, -37), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
#ax4.text(0.05, 0.05, textstr, ha='left', va='bottom', transform=ax4.transAxes, size=9,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
fig.subplots_adjust(hspace=0)
fig.subplots_adjust(wspace=0.3)
#saveFigures(savePath, '180nm_nMOS_short_opt_summary')
plt.show()
```

```{python}
#| label: tbl-sekv_parameters3
#| tbl-cap: Extraction of the sEKV parameters using curve fitting with $\lambda_c > 0$.

sekv_idvg_param_df.loc[len(sekv_idvg_param_df.index)] = [n,Ispecsq/1e-9,VT0/1e-3,lambdac,Lsat/1e-9,"curve fitting with $\\lambda_c > 0$"]
sekv_idvg_param_df = sekv_idvg_param_df.rename(index={2: tYPE})

Markdown(tabulate(
  sekv_idvg_param_df,
  headers=["Type","$n$","$I_{{spec\\Box}}\\;[nA]$","$V_{{T0}}\\;[mV]$","$\\lambda_c$","$L_{{sat}}\\;[nm]$","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center","center","center"),
  floatfmt=(".0f",".2f",".0f",".0f",".3f",".3f",".0f")
))
```

# Output characteristic
## Generating and importing the data
The data used for the sEKV parameters extraction is generated by simulation using the PSP CM @bib:psp103.6:2017 from the PDK of the IHP 130nm process @bib:ihp:2025 for the typical-typical (t-t) case. We present the $I_D$-$V_G$ and $G_m$-$V_G$ data below.

```{python}
simulationPath="./Simulations/" + type + "/idgdsvd/"
dataPath="./Data/" + type + "/"
fileName = "idgdsvd"
dataFile = dataPath + fileName + "_" + type + "_" + size + ".dat"
paramFile = simulationPath + fileName + ".par"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"

VS=0
VD=1.2

idx=0
n=sekv_idvg_param_df.iloc[idx]['n']
Ispecsq=sekv_idvg_param_df.iloc[idx]['Ispecsq']*1e-9
VT0=sekv_idvg_param_df.iloc[idx]['VT0']*1e-3

#n=1.21
#VT0=173e-3
#Ispecsq=825e-9
IC=1
Ispec=Ispecsq*Weff/Leff
ID=Ispec*IC
vps=vps_ic(IC)
nUT=n*UT
VG=VT0+nUT*vps

Npts=201
VDmin=0
VDmax=1.2
dVD=(VDmax-VDmin)/(Npts-1)

if newSim:
    paramstr = '\n'.join((
        f'.param W={W/1e-6:.2f}u L={L/1e-6:.2f}u VG={VG:.1f} VS={VS:.1f} VD={VD:.1f}',
        f'.csparam VDmin = {VDmin:.3f}',
        f'.csparam VDmax = {VDmax:.3f}',
        f'.csparam dVD = {dVD:.3f}'
    ))
    #print(paramstr)
    with open(paramFile, 'w') as f:
        f.write(paramstr)
    print('Starting ngspice simulation...\n')
    result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
    if result.stderr == '':
        print("Simulation executed successfully.\n")
    else:
        print("Simulation failed with return code", result.stderr)
    print(result.stdout)
    f = open(simulationPath + fileName + ".log", 'r')
    log_contents = f.read()
    print("Contents of the log file:")
    print("‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n")
    print (log_contents)
    # We copy the simulation results to the dat folder
    shutil.copy2(simulationData, dataFile)
```

### I~D~ and G~ds~ versus V~D~

```{python}
#| label: fig-id_gds_vd_imported_log
#| fig-cap: Imported $I_D$-$V_D$ and $G_{ds}$-$V_D$.

df_idgdsvd=pd.read_table(dataFile, sep=' +', engine='python')
VD=df_idgdsvd['v-sweep'].to_numpy()
ID=df_idgdsvd['ID'].to_numpy()
Gds=df_idgdsvd['Gds'].to_numpy()

Npts=len(VD)
VDmin=VD[0]
VDmax=VD[Npts-1]

#fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(8, 3), constrained_layout=True)

plt.rcParams.update(twoSidebySidePlotsParams)
fig, axs = plt.subplots(ncols=2, nrows=1, constrained_layout=True)

axs[0].plot(VD, ID/1e-6, 'r-o', markersize=msize, markevery=mevery)
axs[0].set_xlabel('$V_D$ [V]')
axs[0].set_xlim(VDmin,VDmax)
#axs[0].set_xticks(np.arange(0,2.2,0.2))
axs[0].set_ylabel('$I_D$ [$\\mu A$]')
axs[0].set_ylim(0,)
#axs[0].legend(loc='upper left')
mosinfo = '\n'.join((
    Type,
    f'$W =$ {W/1e-6:.0f} $\\mu m$',
    f'$L =$ {L/1e-9:.0f} $nm$',
    f'$V_S =$ {VS:.0f} V',
    f'$IC \\cong$ {IC:.0f}',
    f'$V_G =$ {VG/1e-3:.0f} mV'))
axs[0].text(0.65, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogy(VD, abs(Gds)/1e-6, 'r-o', markersize=msize, markevery=mevery)
axs[1].set_xlabel('$V_D$ [V]')
axs[1].set_xlim(VDmin,VDmax)
#axs[1].set_xticks(np.arange(0,2.2,0.2))
axs[1].set_ylabel('$|G_{ds}|$ [$\\mu A/V$]')
#axs[1].set_ylim(0,)
#axs[1].legend(loc='lower right')
axs[1].text(0.65, 0.95, mosinfo, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

```{python}
#| label: fig-gds_vd_check
#| fig-cap: Check imported $G_{ds}$ against computed $G_{ds}$.

Npts=len(VD)
VDmin=VD[0]
VDmax=VD[Npts-1]
Gdsnum=np.zeros(Npts)
dVD=VD[1]-VD[0]
Gdsnum=diff(ID,dVD)

plt.style.use(pltStyle)
plt.semilogy(VD, Gds/1e-6,'ro', label='Data', markersize=msize, markevery=mevery)
plt.semilogy(VD, Gdsnum/1e-6,'b-', label='Num. diff.')
plt.xlabel('$V_D$ [V]')
plt.xlim(VDmin,VDmax)
#plt.xticks(np.arange(0,2.2,0.2))
plt.ylabel('$G_{ds}$ [$\\mu A/V$]')
#plt.ylim(1e-11,1e-3)
#plt.yticks([1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3])
plt.legend(loc='upper left')
plt.text(0.7, 0.95, mosinfo, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

The output conductance calculated by differentiating the large-signal $I_D$-$V_D$ matches the value extracted from the PSP model. We will keep the value from PSP.

### Filtering the outliers
In order to extract the CLM parameter in saturation, we will now filter out the points that correspond to the linear region. We can do this easily by looking at the $G_{ds}$ versus $V_D$ characteristic as shown in @fig-id_gds_vd_outliers.

```{python}
#| label: fig-id_gds_vd_outliers
#| fig-cap: Filtering the outliers from $I_D$-$V_G$ and $G_{ds}$-$V_D$.

VDmini=0.2
VDmaxi=1.2

VDsub=VD[(VD >= VDmini) & (VD <= VDmaxi)]
Nsub=len(VDsub)
Nmin=np.where(VD == VDsub[0])[0][0]
Nmax=np.where(VD == VDsub[Nsub-1])[0][0]

IDsub=np.zeros(Nsub)
Gdssub=np.zeros(Nsub)

for k in range(0,Nsub):
    IDsub[k]=ID[Nmin+k]
    Gdssub[k]=Gds[Nmin+k]

Nfil=Npts-Nsub
VDfil=np.zeros(Nfil)
IDfil=np.zeros(Nfil)
Gdsfil=np.zeros(Nfil)

for k in range(0,Nfil):
    VDfil[k]=VD[k]
    IDfil[k]=ID[k]
    Gdsfil[k]=Gds[k]

fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(8, 3), constrained_layout=True)

axs[0].plot(VDfil, IDfil/1e-6, 'b-o', label='Outliers', markersize=msize, markevery=mevery)
axs[0].plot(VDsub, IDsub/1e-6, 'r-o', label='Selected', markersize=msize, markevery=mevery)
axs[0].set_xlabel('$V_D$ [V]')
axs[0].set_xlim(VDmin,VDmax)
#axs[0].set_xticks(np.arange(0,2.2,0.2))
axs[0].set_ylabel('$I_D$ [$\\mu A$]')
axs[0].set_ylim(0,)
#axs[0].legend(loc='upper left')
axs[0].text(0.7, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogy(VDfil, abs(Gdsfil)/1e-6, 'b-o', label='Outliers', markersize=msize, markevery=mevery)
axs[1].semilogy(VDsub, abs(Gdssub)/1e-6, 'r-o', label='Selected', markersize=msize, markevery=mevery)
axs[1].set_xlabel('$V_D$ [V]')
axs[1].set_xlim(VDmin,VDmax)
#axs[1].set_xticks(np.arange(0,2.2,0.2))
axs[1].set_ylabel('$|G_{ds}|$ [$\\mu A/V$]')
#axs[1].set_ylim(0,)
#axs[1].legend(loc='lower right')
axs[1].text(0.7, 0.95, mosinfo, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

## Extracting the CLM parameter
The simple channel length modulation (CLM) of the output conductance in saturation is approximated by
\begin{equation}
  G_{ds} = \frac{I_{D,sat}}{V_E}
\end{equation}
where $I_{D,sat}$ is the drain current in saturation and
\begin{equation}
  V_E = \lambda \cdot L_{eff}
\end{equation}
is the Early voltage or CLM voltage which is proportionnal to the effectve length. This corresponds to a linear approximation of the drain current in saturation given by
\begin{equation}
  I_{D,sat} \cong G_{ds} \cdot (V_D - V_E)
\end{equation}
The value $I_{D0}$ corresponds to the intercept
\begin{equation}
  I_{D0} = -G_{ds} \cdot V_E
\end{equation}
which is positive since $V_E$ is negative.

```{python}
#| label: fig-clm_param_ext
#| fig-cap: Extraction of the CLM parameter $\lambda$.

from scipy.stats import linregress

slope, intercept, _, _, _ = linregress(VDsub, IDsub)
Gdsext=slope
ID0ext=intercept
VEext=-ID0ext/Gdsext
lambdaext=-VEext/L

Npts=len(VD)
VDmin=VD[0]
VDmax=VD[Npts-1]

IDfit=np.zeros(Npts)
Gdsfit=np.zeros(Npts)

for k in range(0,Npts):
#    IDfit[k]=ID0ext+Gdsext*VD[k]
    IDfit[k]=Gdsext*(VD[k]-VEext)
    Gdsfit[k]=Gdsext

fig, axs = plt.subplots(ncols=2, nrows=1, figsize=(8, 3), constrained_layout=True)

axs[0].plot(VDfil, IDfil/1e-6, 'b-o', label='Outliers', markersize=msize, markevery=mevery)
axs[0].plot(VDsub, IDsub/1e-6, 'r-o', label='Selected', markersize=msize, markevery=mevery)
axs[0].plot(VD, IDfit/1e-6, 'k--', label='Fit')
axs[0].set_xlabel('$V_D$ [V]')
axs[0].set_xlim(VDmin,VDmax)
#axs[0].set_xticks(np.arange(0,1.6,0.2))
axs[0].set_ylabel('$I_D$ [$\\mu A$]')
axs[0].set_ylim(0,)
#axs[0].legend(loc='upper left')
#axs[0].text(0.7, 0.05, mosinfo, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
textstr1 = '\n'.join((
    f'$I_{{D0}} =$ {ID0ext/1e-6:.3f} $\\mu A$',
    f'$G_{{ds}} =$ {Gdsext/1e-6:.3f} $\\mu A/V$',
    f'$V_E =$ {VEext:.3f} V',
    f'$\\lambda =$ {lambdaext/1e6:.3f} $V/\\mu m$'))
axs[0].text(0.6, 0.05, textstr1, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogy(VDfil, abs(Gdsfil)/1e-6, 'b-o', label='Outliers', markersize=msize, markevery=mevery)
axs[1].semilogy(VDsub, abs(Gdssub)/1e-6, 'r-o', label='Selected', markersize=msize, markevery=mevery)
axs[1].semilogy(VD, Gdsfit/1e-6, 'k--', label='Fit')
axs[1].set_xlabel('$V_D$ [V]')
axs[1].set_xlim(VDmin,VDmax)
#axs[1].set_xticks(np.arange(0,2.2,0.2))
axs[1].set_ylabel('$|G_{ds}|$ [$\\mu A/V$]')
#axs[1].set_ylim(0,)
#axs[1].legend(loc='lower right')
axs[1].text(0.7, 0.95, mosinfo, ha='left', va='top', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

As shown in the left plot of @fig-clm_param_ext, the simple expression of the drain current in saturation gives a rather good fit. The output conductance is approximated by a constant value represented by the dashed black line in the right plot of @fig-clm_param_ext.

We get a rather high output conductance $G_{ds} =$ `{python} f'{Gdsext/1e-6:.3f}'` $\mu A/V$ and hence low value of the $\lambda$ parameter equal to $\lambda =$ `{python} f'{lambdaext/1e6:.3f}'` $V/\mu m$. This is rather normal for this `{python} f'{size}'`-channel transistor. Unfortunately it translates into a poor intrinsic voltage gain $G_m/G_{ds}$.

As shown in the right plot of @fig-clm_param_ext, the output conductance is approximated by a constant value represented by the dashed black line. It is a poor approximation of the output conductance but good enough for starting a design. Note that, in analog circuit design, having a good fit of the output conductance is less important than having a good fit of the transconductance because often we just need the intrinsic voltage gain to be large enough for the circuit to perform correctly, while we want to have a good estimation of the parameters depending on the transconductance, such as the gain-bandwidth product or the thermal noise.

```{python}
#| label: tbl-clm_parameters1
#| tbl-cap: CLM parameters extracted in moderate inversion.

sekv_idvd_param_df={
    "Leff": [Leff/1e-6],
    "IC": [IC],
    "Gds": [Gdsext/1e-6],
    "ID0": [ID0ext/1e-6],
    "VE": [VEext],
    "lambda": [lambdaext/1e6],
    "Comment": "extracted in MI"
}
index_labels=["nMOS"]
sekv_idvd_param_df=pd.DataFrame(sekv_idvd_param_df, index=index_labels)

Markdown(tabulate(
  sekv_idvd_param_df,
  headers=["Type","$L_{{eff}}\\;[\\mu m]$","$IC$","$G_{{ds}}\\;[\\mu A/V]$","$I_{{D0}}\\;[\\mu A]$","$V_E\\;[V]$","$\\lambda\\;[V/\\mu m]$","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center","center","center","center"),
  floatfmt=(".0f",".3f",".3f",".3f",".3f",".3f",".3f",".0f")
))
```

# Noise
In this section we will check the white noise power spectral desnity (PSD) and extract the flicker noise parameters to be used with sEKV. We reuse the flicker noise model from EKV 2.6, where the input (gate) referred PSD is given by
\begin{equation}
  S_{nin,fl}(f) = \frac{KF}{W_{eff}\,L_{eff}\,C_{ox}\; f^{AF}}
\end{equation}
In this model the flicker noise is assumed to scale as $1/C_{ox}$, which is correct if the noise follows the Hooge model (i.e. originates from mobility fluctuations). In the case of the Mc Worther model (i.e. flicker noise originating from traps in the Si-SiO~2~ interface and in the oxyde), the PSD scales as $C_{ox}^2$. Despite the flicker noise is usually dominated by the trapping mechanism, we will keep the above model with a $1/C_{ox}$ scaling.

In EKV, we like to rewrite the flicker noise PSD like the thermal noise in terms of an input-referred noise resistance
\begin{equation}
  S_{nin,fl}(f) = 4 kT\,R_{nin,fl}(f)
\end{equation}
which obviously depends on frequency according to
\begin{equation}
  R_{nin,fl}(f) = \frac{\rho}{W_{eff}\,L_{eff}\,f^{AF}}
\end{equation}
with parameter $\rho$ defined as
\begin{equation}
  \rho = \frac{KF}{4 kT\,C_{ox}}.
\end{equation}
Note that the flicker noise parameter have some weird units. Indeed, $KF$ is in $A \cdot V \cdot s^{2-AF}$ and $\rho$ is in $V \cdot m^2 / (A \cdot s^{AF})$. If $AF = 1$, like it is often the case, then $KF$ is in $A \cdot V \cdot s$ and $\rho$ is in $V \cdot m^2 / (A \cdot s)$.

To extract the noise parameters, we use a common-source stage loaded by a noiseless resistor. We first will set the bias condition in terms of $IC$ and calculate the input-referred white noise to compare it to the result obtained from the PSP simulations.

## Setting the bias conditions
Having extracted $n$, $I_{spec\Box}$ and $V_{T0}$, we can impose the inversion coefficient and calculate the corresponding gate voltage $V_G$. We nee to make sure the transistor remains in saturation.

```{python}
#n=1.21
#VT0=173e-3
#Ispecsq=825e-9
tox=2.2404e-09
Cox=epsilonox*epsilon0/tox
idx=2
n=sekv_idvg_param_df.iloc[idx]['n']
Ispecsq=sekv_idvg_param_df.iloc[idx]['Ispecsq']*1e-9
VT0=sekv_idvg_param_df.iloc[idx]['VT0']*1e-3

VDD=1.2
IC=1
Ispec=Ispecsq*Weff/Leff
ID=Ispec*IC
#qs=q_ic(IC)
vps=vps_ic(IC)
nUT=n*UT
VG=VT0+nUT*vps
VS=0
gms=gms_ic(IC)
Gmekv=Ispec/nUT*gms
gammanekv=gamman_ic(IC,n)
Rnthekv=gammanekv/Gmekv
Snthekv=4*kT*Rnthekv
Vnthekv0=sqrt(Snthekv)
Av=10
RL=Av/Gmekv
VRL=ID*RL
VDS=VDD-VRL
VDSsat=UT*vdssat_ic(IC)
region="saturation" if VDS > VDSsat else "linear"
#print(f'The transistor is biased in the {region} region')
```

We need to check that the transistor is biased in saturation. Setting the inversion coefficient to $IC =$ `{python} f'{IC:.0f}'` we get a drain current $I_D =$ `{python} f'{ID/1e-6:.0f}'` $\mu A$ corresponding to a gate voltage $V_G =$ `{python} f'{VG/1e-3:.0f}'` $mV$. The gate transconductance is estimated at $G_m =$ `{python} f'{Gmekv/1e-6:.3f}'` $\mu A/V$. Setting the voltage gain to $A_v = G_m \cdot R_L =$ `{python} f'{Av:.0f}'` we get $R_L =$ `{python} f'{RL/1e3:.3f}'` $k \Omega$. For $V_{DD} =$ `{python} f'{VDD:.1f}'` $V$ we have $V_{DS} =$ `{python} f'{VDS/1e-3:.0f}'` $mV$. With a saturation voltage $V_{DSsat} =$ `{python} f'{VDSsat/1e-3:.0f}'` $mV$, the transistor is biased in the `{python} f'{region}'` region.

We can now proceed with the noise simulation and extract the PSP parameters and the PSD.

## Extract operating point information

```{python}
simulationPath="./Simulations/" + type + "/noise/"
dataPath="./Data/" + type + "/"
fileName = "noise"
dataFile = dataPath + fileName + "_" + type + "_" + size + ".op.dat"
opFile = simulationPath + fileName + ".op.dat"
paramFile = simulationPath + fileName + ".op.par"
simulationFile = simulationPath + fileName + ".op.cir"
simulationLog = simulationPath + fileName + ".op.log"
simulationData = simulationPath + fileName + ".op.dat"

if newSim:
    paramstr = '\n'.join((
        f'.param VDD={VDD:.1f} VG={VG:.3f} RL={RL/1e3:.3f}k',
        f'.param W={W/1e-6:.0f}u L={L/1e-6:.2f}u'
    ))
    print(paramstr)
    with open(paramFile, 'w') as f:
        f.write(paramstr)
    print('Starting ngspice simulation...\n')
    result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
    if result.stderr == '':
        print("Simulation executed successfully.\n")
    else:
        print("Simulation failed with return code", result.stderr)
    print(result.stdout)
    f = open(simulationLog, 'r')
    log_contents = f.read()
    print("Contents of the log file:")
    print("‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n")
    print (log_contents)
    # We copy the simulation results to the dat folder
    shutil.copy2(simulationData, dataFile)
```

We can now check the operating point and extract the PSP noise parameters. The PSP operating point information are given in @tbl-pspop and the PSP noise parameters are given in @tbl-pspnoise.


```{python}
#| label: tbl-pspop
#| tbl-cap: PSP operating point.

mosop_df=pd.read_table(dataFile, sep=r'\s+', dtype=np.float64, engine='python')
mosop_df=mosop_df.rename(columns={'@n.xp.nsg13_lv_pmos[weff]': 'Transistor',
                              '@n.xp.Nsg13_lv_pmos[weff]': 'Weff',
                              '@n.xp.Nsg13_lv_pmos[leff]': 'Leff',
                              '@n.xp.Nsg13_lv_pmos[ids]': 'IDS',
                              '@n.xp.Nsg13_lv_pmos[gm]': 'Gm',
                              '@n.xp.Nsg13_lv_pmos[gds]': 'Gds',
                              '@n.xp.Nsg13_lv_pmos[sid]': 'Snidth',
                              '@n.xp.Nsg13_lv_pmos[sqrtsfw]': 'Vninth',
                              '@n.xp.Nsg13_lv_pmos[sfl]': 'Snidfl @ 1Hz',
                              '@n.xp.Nsg13_lv_pmos[sqrtsff]': 'Vninfl @ 1kHz',
                              '@n.xp.Nsg13_lv_pmos[fknee]': 'fk'
                    })
mosop_df['Transistor'] = mosop_df['Transistor'].astype(str)
mosop_df.at[0, 'Transistor'] = 'Mn'
mosop_df.set_index('Transistor', inplace=True)
mosop_df.rename_axis(index=None, inplace=True)

Weffpsp=mosop_df.at['Mn','Weff']
Leffpsp=mosop_df.at['Mn','Leff']
Gmpsp=mosop_df.at['Mn','Gm']
Snidthpsp=mosop_df.at['Mn','Snidth']
Snidfl1Hzpsp=mosop_df.at['Mn','Snidfl @ 1Hz']
Snthpsp=Snidthpsp/Gmpsp**2
Vnthpsp0=mosop_df.at['Mn','Vninth']
Snfl1Hzpsp=Snidfl1Hzpsp/Gmpsp**2
Vnfl1Hzpsp=sqrt(Snfl1Hzpsp)
Vnfl1kHzpsp=mosop_df.at['Mn','Vninfl @ 1kHz']
KFpsp=Snfl1Hzpsp*Weffpsp*Leffpsp*Cox # Definition from EKV 2.6
KFlong=KFpsp
rhopsp=KFpsp/(4*kT*Cox)
rholong=rhopsp
AFpsp=log(Snfl1Hzpsp/Vnfl1kHzpsp**2)/3
fkpsp=mosop_df.at['Mn','fk']
Rnthpsp=Snthpsp/(4*kT)
gammanpsp=Gmpsp*Rnthpsp

pspop_df={
    "Weff": [mosop_df.at['Mn','Weff']/1e-6],
    "Leff": [mosop_df.at['Mn','Leff']/1e-9],
    "IDS": [mosop_df.at['Mn','IDS']/1e-6],
    "Gm": [mosop_df.at['Mn','Gm']/1e-6],
    "Gds": [mosop_df.at['Mn','Gds']/1e-6],
    "Comment": "extracted from PSP"
}

index_labels=["Mp"]
pspop_df=pd.DataFrame(pspop_df, index=index_labels)

Markdown(tabulate(
  pspop_df,
  headers=["Transistor","$W_{eff}\\;[\\mu m]$","$L_{eff}\\;[\\mu m]$","$I_{DS}\\;[\\mu A]$","$G_m\\;[\\mu A/V]$","$G_{ds}\\;[\\mu A/V]$","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center","center","center"),
  floatfmt=(".0f",".3f",".0f",".3f",".3f",".3f",".0f")
))
```

```{python}
#| label: tbl-pspnoise
#| tbl-cap: MOS PSP noise parameters.

pspnoise_df={
    "Vninth": [mosop_df.at['Mn','Vninth']/1e-9],
    "Vninfl @ 1kHz": [mosop_df.at['Mn','Vninfl @ 1kHz']/1e-9],
    "fk": [mosop_df.at['Mn','fk']/1e6],
    "Comment": "extracted from PSP"
}

index_labels=["Mp"]
pspnoise_df=pd.DataFrame(pspnoise_df, index=index_labels)

Markdown(tabulate(
  pspnoise_df,
  headers=["Transistor","$\\sqrt{S_{ninth}}\\;[nV/\\sqrt{Hz}]$","$\\sqrt{S_{ninfl}(1 kHz)}\\;[nV/\\sqrt{Hz}]$","$f_k\\;[MHz]$","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center"),
  floatfmt=(".0f",".1f",".1f",".3f",".0f")
))
```

We see that the simulated bias current $I_D =$ `{python} f'{mosop_df.at['Mn','IDS']/1e-6:.2f}'` $\mu A$ is lower than the desired current $I_D =$ `{python} f'{ID/1e-6:.2f}'` $\mu A$ resulting in a smaller simulated transconductance $G_m =$ `{python} f'{mosop_df.at['Mn','Gm']/1e-6:.2f}'` $\mu A/V$ compared to the predicted one $G_m =$ `{python} f'{Gmekv/1e-6:.2f}'` $\mu A/V$. This will lead to a higher simulated white noise compared to the predicted one.

```{python}
# Re-estimate the transcondcutance and noise parameters

IDsim=mosop_df.at['Mn','IDS']
ICsim=IDsim/Ispec
gms=gms_ic(ICsim)
Gmekv=Ispec/nUT*gms
gammanekv=gamman_ic(IC,n)
Rnthekv=gammanekv/Gmekv
Snthekv=4*kT*Rnthekv
Vnthekv0=sqrt(Snthekv)
```

We can re-estimate the EKV transconductance from the simulated current. The inversion coefficient corresponding to the simulated current is $IC =$ `{python} f'{ICsim:.3f}'` instead of $IC =$ `{python} f'{IC:.3f}'`. This gives $G_m =$ `{python} f'{Gmekv/1e-6:.2f}'` $\mu A/V$ which is much closer to the PSP simulated value $G_m =$ `{python} f'{mosop_df.at['Mn','Gm']/1e-6:.2f}'` $\mu A/V$.


## Simulating noise PSD
We can now simulate the PSD and check against the EKV model. The square roots of the PSD are plotted versus frequency in @fig-noise_psd.

```{python}
simulationPath="./Simulations/" + type + "/noise/"
dataPath="./Data/" + type + "/"
fileName = "noise"
dataFile = dataPath + fileName + "_" + type + "_" + size + ".dat"
paramFile = simulationPath + fileName + ".par"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"

fmin=1
fmax=1e10
decPts=21

if newSim:
    paramstr = '\n'.join((
        f'.param VDD={VDD:.1f} VG={VG:.3f} RL={RL/1e3:.0f}k',
        f'.param W={W/1e-6:.2f}u L={L/1e-6:.2f}u',
        f'.csparam fmin = {fmin:.0e}',
        f'.csparam fmax = {fmax:.0e}',
        f'.csparam decPts = {decPts:.0f}'
    ))
    print(paramstr)
    with open(paramFile, 'w') as f:
        f.write(paramstr)
    print('Starting ngspice simulation...\n')
    result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
    if result.stderr == '':
        print("Simulation executed successfully.\n")
    else:
        print("Simulation failed with return code", result.stderr)
    print(result.stdout)
    f = open(simulationLog, 'r')
    log_contents = f.read()
    print("Contents of the log file:")
    print("‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n")
    print (log_contents)
    # We copy the simulation results to the dat folder
    shutil.copy2(simulationData, dataFile)
```

```{python}
#| label: fig-noise_psd
#| fig-cap: Output and input-referred PSD.

df_noise=pd.read_table(dataFile, sep=' +', engine='python')
freq=df_noise['frequency'].to_numpy()
Vninpsp=df_noise['inoise_spectrum'].to_numpy()
Vnoutpsp=df_noise['onoise_spectrum'].to_numpy()

Npts=len(freq)
fmin=freq[0]
fmax=freq[Npts-1]

Vnthekv=np.zeros(Npts)
Snflekv=np.zeros(Npts)
Vnflekv=np.zeros(Npts)

for k in range(0,Npts):
    Vnthekv[k]=Vnthekv0
    Snflekv[k]=KFpsp/(Weff*Leff*Cox*freq[k])
    Vnflekv[k]=sqrt(Snflekv[k])

plt.style.use(pltStyle)
plt.loglog(freq, Vnoutpsp,'r-', label='Output noise (PSP)')
plt.loglog(freq, Vninpsp,'b-', label='Input noise (PSP)')
plt.loglog(freq, Vnthekv,'k--', label='White input noise (sEKV)')
plt.loglog(freq, Vnflekv,'k-.', label='Flicker input noise (model)')
#plt.loglog([fk,fk],[1e-10,Vnth],'k--')
plt.xlim(fmin,fmax)
#plt.xticks([1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8,1e9])
plt.xlabel('Frequency [Hz]')
plt.ylim(1e-9,1e-5)
plt.ylabel('$\\sqrt{S_{nout}}$ and $\\sqrt{S_{nin}}$ $[V/\\sqrt{Hz}]$')
plt.legend(loc='lower left', fontsize=9)
#plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
textstr1 = '\n'.join((
    Type,
    f'$W =$ {W/1e-6:.0f} $\\mu m$',
    f'$L =$ {L/1e-9:.0f} $nm$'))
textstr2 = '\n'.join((
    f'$IC =$ {ICsim:.3f}',
    f'$V_G =$ {VG:.3f} V',
    f'$V_{{DS}} =$ {VDS:.3f} V',
    f'$R_L =$ {RL/1e3:.1f} $k\\Omega$'))
textstr3 = '\n'.join((
    f'$G_m =$ {Gmpsp/1e-6:.3f} $\\mu A/V$ (PSP)',
    f'$G_m =$ {Gmekv/1e-6:.3f} $\\mu A/V$ (EKV)',
    f'$\\sqrt{{S_{{in,th}}}} =$ {Vnthpsp0:.3e} (PSP)',
    f'$\\sqrt{{S_{{in,th}}}} =$ {Vnthekv0:.3e} (EKV)',
#    f'$R_{{n,th}} =$ {Rnthpsp/1e3:.3f} $k\\Omega$ (PSP)',
#    f'$R_{{n,th}} =$ {Rnthekv/1e3:.3f} $k\\Omega$ (EKV)',
    f'$\\gamma_n =$ {gammanpsp:.3f} (PSP)',
    f'$\\gamma_n =$ {gammanekv:.3f} (EKV)',
    f'$KF =$ {KFpsp:.3e} $V A s$ (PSP)',
    f'$\\rho =$ {rhopsp:.3e} $V m^2/(A s)$ (PSP)',
    f'$AF =$ {AFpsp:.3f} (PSP)',
    f'$f_k =$ {fkpsp/1e6:.3f} MHz (PSP)'))
plt.text(0.4, 0.95, textstr1, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.text(0.7, 0.95, textstr2, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.text(1.05, 0.5, textstr3, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
#plt.text(fk, 1e-9, '$f_k =$'+f'{fk/1e3:.0f} kHz', ha='left', va='bottom', size=14)
#plt.text(1e2, Vnth, '$\sqrt{S_{nin,th}} =$'+f'{Vnth/1e-9:.1f} '+'$nV/\sqrt{Hz}$', ha='center', va='bottom', size=14)
#saveFigures(savePath, 'Input_referred_noise_PSD')
plt.show()
```

Even after updating the inversion coefficient and transconductance, we see that the PSP white noise is higher than the sEKV estimation, despite the transconductances are close. This is due to a larger PSP thermal noise excess factor $\gamma_n =$ `{python} f'{gammanpsp:.3f}'` compared to the sEKV one $\gamma_n =$ `{python} f'{gammanekv:.3f}'`. On the other hand the sEKV input-referred flicker noise estimation is right on top of PSP. The extracted sEKV flicker noise parameters are given in @tbl-flicker_noise_parameters.

```{python}
#| label: tbl-flicker_noise_parameters
#| tbl-cap: Extraction of the sEKV flicker noise parameters.

KFn=KFpsp
rhon=rhopsp
AFn=AFpsp

sekv_noise_param_df={
    "Weff": [Weff/1e-6],
    "Leff": [Leff/1e-9],
    "IC": [ICsim],
    "KF": [KFn],
    "AF": [AFn],
    "rho": [rhon],
    "Comment": "moderate"
}
index_labels=["Mp"]
sekv_noise_param_df=pd.DataFrame(sekv_noise_param_df, index=index_labels)
sekv_noise_param_df

Markdown(tabulate(
  sekv_noise_param_df,
  headers=["Transistor","$W_{{eff}}\\;[\\mu m]$","$L_{{eff}}\\;[nm]$","$IC$ [-]","$KF\\;[J]$","$AF$ [-]","$\\rho_n\\;\\left[\\frac{V\\,m^2}{A\\,s}\\right]$","Comment"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center","center","center","center","center"),
  floatfmt=(".0f",".3f",".0f",".3f",".3e",".3f",".3e",".0f")
))
```

```{python}
with pd.ExcelWriter("sEKV_ihp130nm_pmos_short.xlsx") as writer:
    sekv_geom_param_df.to_excel(writer, sheet_name="geometric parameters (pMOS)")
    sekv_idvg_param_df.to_excel(writer, sheet_name="idvg parameters (pMOS)")
    sekv_idvd_param_df.to_excel(writer, sheet_name="idvd parameters (pMOS)")
    sekv_noise_param_df.to_excel(writer, sheet_name="noise parameters (pMOS)")
```

# Conclusion
This notebook presented different approaches to extract the sEKV parameters for a `{python} f'{size}'`-channel `{python} f'{tYPE}'` transistor for the 130nm IHP BiCMOS technology. The data was first obtained by simulations using the PSP compact model and the IHP PDK.

The sEKV parameters were first extracted using a direct extraction methodology with $\lambda_c =0$. This results in a good fit over all regions of operation except in very strong inversion because of the combined effects of velocity saturation and mobility reduction due to the vertical field.
The direct extraction approach is then used to also extract the velocity saturation parameter $\lambda_c$. After some tuning we can get a very good fit in all regions of operation including strong inversion.

The sEKV parameters are then extracted using curve fitting which immediately gives a good result in all regions of operation with values that are close to those extractied with the direct extraction methodology.

The parameters for the output conductance due to CLM are then extracted in moderate inversion.

We also have checked the noise in moderate inversion and shown that the thermal noise which is slightly higher for the PSP model compared to the sEKV mode despite the transconductance being almost equal between PSP and sEKV. This comes from a larger thermal noise excess factor in PSP compared to sEKV. We have finally also extracted the flicker noise parameters.

Overall we have shown that sEKV can fit the large- and small-signal data of this is a `{python} f'{size}'`-channel `{python} f'{tYPE}'` transistor very well except for white noise which is higher in PSP compared to sEKV.

# References
